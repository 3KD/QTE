#!/usr/bin/env python3
"""
infer_requirements.py
- Prints the first 20 lines of each .py under a folder
- Scans imports and proposes a requirements.txt

Usage:
  python infer_requirements.py ~/Desktop/program5_branch_series > scan.log
  # requirements are echoed at the end and also written to requirements.auto.txt
"""
import ast
import os
import sys
from pathlib import Path
from typing import Set, Dict, Iterable

# Map import top-level module -> pip package name
PKG_MAP: Dict[str, str] = {
    # scientific
    "numpy": "numpy",
    "matplotlib": "matplotlib",
    "sklearn": "scikit-learn",
    "scipy": "scipy",
    "pandas": "pandas",
    # qiskit ecosystem
    "qiskit": "qiskit",
    "qiskit_aer": "qiskit-aer",
    "qiskit_experiments": "qiskit-experiments",
    # other common libs
    "networkx": "networkx",
    "sympy": "sympy",
    "PIL": "Pillow",
    # gui
    "tkinter": None,  # stdlib; needs OS tk installed
}
# Treat these as stdlib, so we donâ€™t suggest pip packages for them.
STDLIB_HINT: Set[str] = {
    "tkinter", "typing", "pathlib", "os", "sys", "math", "cmath", "itertools",
    "functools", "json", "re", "collections", "dataclasses", "subprocess",
    "random", "time", "argparse", "fractions", "enum", "statistics", "typing_extensions",
}

def iter_py_files(root: Path) -> Iterable[Path]:
    for p in root.rglob("*.py"):
        # skip venvs or cache folders
        if any(part in (".venv", "venv", "__pycache__", ".mypy_cache", ".ruff_cache") for part in p.parts):
            continue
        yield p

def print_heads(root: Path) -> None:
    print("\n=== HEADS (first 20 lines) ===\n")
    for p in sorted(iter_py_files(root)):
        print(f"--- {p} ---")
        try:
            with p.open("r", encoding="utf-8", errors="replace") as f:
                for i, line in enumerate(f):
                    if i >= 20: break
                    print(line.rstrip("\n"))
        except Exception as e:
            print(f"[error reading {p}: {e}]")
        print()

def collect_imports(root: Path) -> Set[str]:
    mods: Set[str] = set()
    local_names = {p.stem for p in iter_py_files(root)}
    for p in iter_py_files(root):
        try:
            src = p.read_text(encoding="utf-8", errors="replace")
            tree = ast.parse(src, filename=str(p))
        except Exception:
            continue
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for n in node.names:
                    top = (n.name.split(".")[0]).strip()
                    if top and top not in local_names:
                        mods.add(top)
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    top = (node.module.split(".")[0]).strip()
                    if top and top not in local_names and node.level == 0:
                        mods.add(top)
    return mods

def propose_requirements(mods: Set[str]) -> str:
    required: Set[str] = set()
    optional: Set[str] = set()
    unknown: Set[str] = set()

    for m in sorted(mods):
        if m in STDLIB_HINT:
            continue
        pkg = PKG_MAP.get(m)
        if pkg is None:
            # known stdlib (e.g., tkinter) or intentionally skipped
            continue
        if pkg:
            required.add(pkg)
        else:
            unknown.add(m)

    # Heuristics: if core qiskit is used, suggest aer too if qiskit_aer import present
    # (already handled via map), and keep experiments if imported.
    lines = []
    lines.append("# Auto-generated by infer_requirements.py")
    for pkg in sorted(required):
        lines.append(pkg)
    if optional:
        lines.append("")
        lines.append("# Optional:")
        for pkg in sorted(optional):
            lines.append(pkg)
    if unknown:
        lines.append("")
        lines.append("# Unknown imports (map to pip name manually if needed):")
        for m in sorted(unknown):
            lines.append(f"#   {m}")

    return "\n".join(lines) + "\n"

def main():
    root = Path(sys.argv[1]).expanduser().resolve() if len(sys.argv) > 1 else Path.cwd()
    if not root.exists():
        print(f"Folder not found: {root}", file=sys.stderr)
        sys.exit(1)
    print_heads(root)
    mods = collect_imports(root)
    req = propose_requirements(mods)
    print("\n=== PROPOSED requirements.txt ===\n")
    print(req)
    out = root / "requirements.auto.txt"
    out.write_text(req, encoding="utf-8")
    print(f"[wrote] {out}")

if __name__ == "__main__":
    main()

