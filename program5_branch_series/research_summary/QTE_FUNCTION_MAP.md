## QTEGUI.py
- **SyntaxError:** invalid syntax (line 150)

## _archive/GTEGUI.py
- `__init__(self)`  (L50)
- `_build_tab_amplitudes(self)`  (L458)
- `_build_tab_basis(self)`  (L719)
- `_build_tab_clustering(self)`  (L507)
- `_build_tab_entanglement(self)`  (L574)
- `_build_tab_fft(self)`  (L291)
- `_build_tab_gates(self)`  (L654)
- `_build_tab_measure(self)`  (L434)
- `_build_tab_preview(self)`  (L187)
- `_build_tab_qft(self)`  (L346)
- `_build_tab_similarity(self)`  (L486)
- `_build_tab_state_io(self)`  (L688)
- `_build_tab_tomography(self)`  (L540)
- `_center_hann(self, vec)`  (L746)
- `_get_active_or_selected(self, combo)`  (L162)
- `_maybe_prompt_ibm(self)`  (L140)
- `_refresh_all_combos(self)`  (L170)
- `_register_combo(self, cb)`  (L175)
- `_set_active(self, label, sv, also_save)`  (L154)
- `_set_status(self, msg)`  (L180)
- `_spectrum_metrics(self, vec)`  (L754)
- `on_build_qft_spectrum(self)`  (L366)
- `on_clustering(self)`  (L514)
- `on_compute_fft(self)`  (L302)
- `on_draw_prep_for_last(self)`  (L670)
- `on_draw_qft(self)`  (L660)
- `on_ent_analyze(self)`  (L601)
- `on_load_state(self)`  (L707)
- `on_measure_state(self)`  (L441)
- `on_plot_amplitudes(self)`  (L472)
- `on_prepare_state(self)`  (L248)
- `on_preview_amplitudes(self)`  (L199)
- `on_run_qft_circuit(self)`  (L401)
- `on_run_tomography(self)`  (L549)
- `on_save_active(self)`  (L693)
- `on_set_active_from_amp(self)`  (L467)
- `on_set_active_from_basis(self)`  (L728)
- `on_show_basis(self)`  (L733)
- `on_similarity(self)`  (L491)
- `on_simulate_qft_statevector(self)`  (L420)

## _archive/QTEGUI1.py
- `_canonical_method(label, method)`  (L66)
- `_constants_to_syntax(pairs)`  (L145)
- `_norm_label(label)`  (L58)
- `_parse_constants_syntax(s)` — Grammar (informal):  (L94)
- `_split_top_level(s)`  (L75)
- `_supports_method(label)`  (L62)
- `__init__(self, master, initial)`  (L156)
- `_add_custom(self)`  (L227)
- `_apply_method(self)`  (L218)
- `_cancel(self)`  (L243)
- `_current_highlight(self)`  (L212)
- `_ok(self)`  (L235)
- `_on_select(self, _evt)`  (L203)
- `__init__(self)`  (L252)
- `_build_tab_amplitudes(self)`  (L893)
- `_build_tab_basis(self)`  (L1156)
- `_build_tab_clustering(self)`  (L942)
- `_build_tab_entanglement(self)`  (L1009)
- `_build_tab_fft(self)`  (L610)
- `_build_tab_gates(self)`  (L1084)
- `_build_tab_measure(self)`  (L747)
- `_build_tab_preview(self)`  (L468)
- `_build_tab_qft(self)`  (L659)
- `_build_tab_similarity(self)`  (L921)
- `_build_tab_state_io(self)`  (L1118)
- `_build_tab_tomography(self)`  (L975)
- `_center_hann(self, vec)`  (L1183)
- `_current_constants(self, default_if_empty)`  (L365)
- `_fmt_amp(self, a)`  (L387)
- `_get_active_or_selected(self, combo)`  (L443)
- `_maybe_prompt_ibm(self)`  (L344)
- `_parse_multi_label(self, label)` — Parse labels like: multi[π,e,ln(2)|chain|3] → (['π','e','ln(2)'], 'chain', 3).  (L411)
- `_preview_multi_registers(self, pairs, mode, n_each)` — Print per-register preview for multi selections.  (L390)
- `_refresh_all_combos(self)`  (L451)
- `_register_combo(self, cb)`  (L456)
- `_schmidt_entropy_bits(self, sv, cut)` — Von Neumann entropy (bits) of left block of 'cut' qubits vs the rest (pure state).  (L424)
- `_set_active(self, label, sv, also_save)`  (L435)
- `_set_status(self, msg)`  (L461)
- `_single_constant_required(self, ctx)`  (L378)
- `_spectrum_metrics(self, vec)`  (L1188)
- `on_build_qft_spectrum(self)`  (L678)
- `on_clustering(self)`  (L949)
- `on_compute_fft(self)`  (L618)
- `on_draw_prep_for_last(self)`  (L1100)
- `on_draw_qft(self)`  (L1090)
- `on_ent_analyze(self)`  (L1035)
- `on_load_state(self)`  (L1141)
- `on_measure_state(self)`  (L761)
- `on_pick_constants(self)`  (L358)
- `on_plot_amplitudes(self)`  (L907)
- `on_prepare_state(self)`  (L533)
- `on_preview_amplitudes(self)`  (L478)
- `on_run_qft_circuit(self)`  (L715)
- `on_run_tomography(self)`  (L984)
- `on_save_active(self)`  (L1123)
- `on_set_active_from_amp(self)`  (L902)
- `on_set_active_from_basis(self)`  (L1165)
- `on_show_basis(self)`  (L1170)
- `on_show_marginals(self)`  (L851)
- `on_similarity(self)`  (L926)
- `on_simulate_qft_statevector(self)`  (L734)

## _archive/QTEGUI2.py
- `_canonical_method(label, method)`  (L66)
- `_constants_to_syntax(pairs)`  (L145)
- `_norm_label(label)`  (L58)
- `_parse_constants_syntax(s)` — Grammar (informal):  (L94)
- `_split_top_level(s)`  (L75)
- `_supports_method(label)`  (L62)
- `__init__(self, master, initial)`  (L156)
- `_add_custom(self)`  (L227)
- `_apply_method(self)`  (L218)
- `_cancel(self)`  (L243)
- `_current_highlight(self)`  (L212)
- `_ok(self)`  (L235)
- `_on_select(self, _evt)`  (L203)
- `__init__(self)`  (L252)
- `_build_tab_amplitudes(self)`  (L925)
- `_build_tab_basis(self)`  (L1250)
- `_build_tab_clustering(self)`  (L997)
- `_build_tab_entanglement(self)`  (L1097)
- `_build_tab_fft(self)`  (L610)
- `_build_tab_gates(self)`  (L1172)
- `_build_tab_measure(self)`  (L747)
- `_build_tab_preview(self)`  (L468)
- `_build_tab_qft(self)`  (L659)
- `_build_tab_similarity(self)`  (L953)
- `_build_tab_state_io(self)`  (L1212)
- `_build_tab_tomography(self)`  (L1046)
- `_center_hann(self, vec)`  (L1277)
- `_current_constants(self, default_if_empty)`  (L365)
- `_fmt_amp(self, a)`  (L387)
- `_get_active_or_selected(self, combo)`  (L443)
- `_maybe_prompt_ibm(self)`  (L344)
- `_parse_multi_label(self, label)` — Parse labels like: multi[π,e,ln(2)|chain|3] → (['π','e','ln(2)'], 'chain', 3).  (L411)
- `_preview_multi_registers(self, pairs, mode, n_each)` — Print per-register preview for multi selections.  (L390)
- `_refresh_all_combos(self)`  (L451)
- `_register_combo(self, cb)`  (L456)
- `_schmidt_entropy_bits(self, sv, cut)` — Von Neumann entropy (bits) of left block of 'cut' qubits vs the rest (pure state).  (L424)
- `_set_active(self, label, sv, also_save)`  (L435)
- `_set_status(self, msg)`  (L461)
- `_single_constant_required(self, ctx)`  (L378)
- `_spectrum_metrics(self, vec)`  (L1282)
- `on_build_qft_spectrum(self)`  (L678)
- `on_clustering(self)`  (L1007)
- `on_compute_fft(self)`  (L618)
- `on_draw_prep_for_last(self)`  (L1192)
- `on_draw_qft(self)`  (L1178)
- `on_ent_analyze(self)`  (L1123)
- `on_load_state(self)`  (L1235)
- `on_measure_state(self)`  (L775)
- `on_pick_constants(self)`  (L358)
- `on_plot_amplitudes(self)`  (L939)
- `on_prepare_state(self)`  (L533)
- `on_preview_amplitudes(self)`  (L478)
- `on_run_qft_circuit(self)`  (L715)
- `on_run_tomography(self)`  (L1055)
- `on_save_active(self)`  (L1217)
- `on_set_active_from_amp(self)`  (L934)
- `on_set_active_from_basis(self)`  (L1259)
- `on_show_basis(self)`  (L1264)
- `on_show_marginals(self)`  (L883)
- `on_similarity(self)`  (L961)
- `on_simulate_qft_statevector(self)`  (L734)

## catalog_fixes.py
- `erf_coefficient(n)` — erf(x) = (2/√π) Σ_{m≥0} (-1)^m x^{2m+1} / (m!(2m+1))  (L5)

## cli_runner.py
- `main()`  (L24)
- `print_top_basis_states(statevector, label, k)`  (L16)

## dual_rail_composition.py
- `compose_dual_rail(psiA, psiB, U, alpha, beta)` — Return a minimal, backend-agnostic spec for an ancilla-tagged superposition:  (L6)
- `decompose_dual_rail(spec)` — Inverse helper: (psiA, psiB, U, alpha, beta).  (L24)

## experiments/ramsey_pi_sweep.py
- `build(phi_param)`  (L9)
- `run(backend_name, shots, npts, span)`  (L16)

## file_naming.py
- `_ascii_safe(s)`  (L19)
- `build_qte_filename(constants, mode, n_qubits, phase_mode, regq, topology, pattern, entropies_bits, extra, suffix)` — Canonical pattern:  (L81)
- `ent_tag_from_entropies(ents, millis)`  (L71)
- `format_constant_list(pairs)`  (L35)
- `format_constant_token(label, method)`  (L29)
- `parse_multi_label(label)` — multi[π,e,ln(2)|chain|3] -> (['π','e','ln(2)'], 'chain', 3) or None.  (L40)
- `parse_qte_filename(name)`  (L123)
- `schmidt_entropies_all_cuts(sv, regq, n_regs, tol)` — Von Neumann entropy (bits) across every register boundary cut.  (L55)

## harmonic_analysis.py
- `_hann_window(n)`  (L42)
- `compute_fft_spectrum_from_amplitudes(amplitudes, remove_dc, window, pad_len)`  (L75)
- `compute_fft_spectrum_from_amplitudes(amps, remove_dc, window, pad_len)`  (L101)
- `kl_divergence(p, q, eps)`  (L33)
- `plot_spectrum(power, freqs, title)`  (L89)
- `power_spectrum(x)`  (L8)
- `preprocess_amplitudes(amplitudes, remove_dc, window, pad_len, use_magnitude_if_complex)`  (L47)
- `spectral_entropy(power)`  (L15)
- `spectrum_metrics(power)`  (L20)

## ibm_backend.py
- `_pick_provider_backend(min_qubits, name)`  (L46)
- `_pick_runtime_backend(min_qubits, name)`  (L72)
- `get_backend(use_ibm, fallback, min_qubits, name)` — Returns a backend-like object with .run(...).  (L105)
- `get_ibm_status()`  (L142)
- `initialize_ibm(api_token, instance)` — Initialize IBM access. Tries qiskit-ibm-provider first, then qiskit-ibm-runtime.  (L10)
- `list_ibm_backends()`  (L128)

## infer_requirements.py
- `collect_imports(root)`  (L63)
- `iter_py_files(root)`  (L43)
- `main()`  (L121)
- `print_heads(root)`  (L50)
- `propose_requirements(mods)`  (L85)

## metrics_extra.py
- `phase_coherence(c)`  (L20)
- `qfi_pure_state(psi, H)` — F_Q = 4(⟨H^2⟩ - ⟨H⟩^2) for a pure state.  (L41)
- `schmidt_entropy(psi, n_qubits, cut)` — Von Neumann entropy across bipartition (pure state).  (L28)
- `spectral_entropy_fft(x)`  (L5)
- `spectral_entropy_hankel(x, nu)`  (L54)
- `spectral_flatness_fft(x)`  (L13)

## paper_batch.py
- `safename(s)`  (L17)

## paper_multi.py
- `entropy_from_svals(S)`  (L20)
- `safe(s)`  (L17)

## precision_scaling.py
- `fidelity_upper_bound(d, L)` — Rough analysis:  (L3)

## qte_cli.py
- `main()`  (L7)

## qte_metrics.py
- `amplitude_entropy(vec)` — Shannon entropy (bits) of |amp|^2.  (L16)
- `compute_metrics(spec, sv)`  (L79)
- `prepare_state(spec)`  (L69)
- `safe_label_method(label, method)`  (L40)
- `save_plots(outdir, base, sv, pad_len)`  (L102)
- `spectral_metrics(vec, pad_len)` — Use your existing harmonic_analysis helper for consistency.  (L22)

## qte_smoke.py

## quantum_embedding.py
- `_center_hann(vec)`  (L39)
- `_ensure_unit(vec)`  (L32)
- `_n_from_len(L)`  (L58)
- `_spectrum_metrics(vec)`  (L48)
- `analyze_tensor_structure(sv, cut)` — Return (rhoA, rhoB, rhoAB) where the bipartition is [0..cut-1] | [cut..n-1].  (L219)
- `digit_qrom_circuit(label, base, n_index, bits_per_digit, method, do_measure)` — Simulation-friendly QROM:  (L294)
- `encode_entangled_constants(c1, c2)` — Minimal 2-qubit entangled encoding: |ψ> = a|00> + b|11>, with a∝c1, b∝c2.  (L134)
- `entangle_series_multi(labels, n_qubits_each, methods, phase_mode, topology, use_stateprep, do_measure)`  (L178)
- `entangle_series_registers(const1, const2, n_qubits_each, method1, method2, phase_mode1, phase_mode2, pattern, use_stateprep, do_measure)`  (L145)
- `generate_series_encoding(label, n_qubits, method, phase_mode, amp_mode)`  (L83)
- `index_qft_spectrum_circuit(vec, use_stateprep, do_measure)`  (L97)
- `perform_schmidt_decomposition(sv, cut)`  (L235)
- `periodic_phase_state(p, q, n_qubits, do_measure, apply_qft)` — Prepare |ψ> with amplitudes ψ[n] ∝ exp(2πi p n / q), n=0..N-1 (uniform magnitude).  (L274)
- `qft_spectrum_from_series(label, n_qubits, method, phase_mode, amp_mode, preprocess, use_stateprep, do_measure, pad_len)`  (L115)
- `run_circuit(qc, use_ibm, measure, shots)`  (L69)
- `simulate_statevector(qc)`  (L66)
- `value_phase_estimation_circuit(label, K, method, do_measure)` — PEA for a 'black-box' phase U = e^{2πi x}, where x = frac(constant(label)).  (L243)

## rail_masks.py
- `block_masks(d, blocks)`  (L9)
- `carriers(d, ks)` — OFDM-style carriers r_k(i) = exp(2π i k i / d) as (d x len(ks)) matrix.  (L14)
- `even_odd_masks(d)`  (L5)

## run_gui.py

## run_series_grid.py
- `build(A, B, N, phase, amp, op)`  (L37)
- `main()`  (L62)
- `make_label(A, B, N, phase, amp, op)`  (L30)

## sbrv_precision.py
- `build_sbrv(a, L, step)` — Build SBRV:  (L14)
- `quantize_msb(a, step)` — Coarse quantizer capturing MSB-scale structure.  (L6)
- `reconstruct_sbrv(a0, stack, L)` — Reconstruct (to level L) and L2-normalize.  (L37)

## scripts/_sampler_utils.py
- `_counts_from_quasi(qd, width, shots)`  (L44)
- `_normalize_counts(d, width)`  (L28)
- `_to_bits(k, width)`  (L13)
- `get_backend(name)`  (L9)
- `run_counts(qc, backend, shots)`  (L57)

## scripts/qpsk_end2end.py
- `_as_counts_from_quasi(qd, width, shots)` — qd: dict-like (keys can be int or bitstrings); return int counts dict or None.  (L35)
- `_normalize_counts(cd, width)` — cd: dict mapping bitstrings/ints→counts; returns {bitstring: int} or None.  (L67)
- `count_twoq(tqc)`  (L27)
- `extract_counts(res, width, shots, circuit, backend)` — Make counts from a Sampler result across API shapes:  (L99)
- `iqft_gate(n)`  (L13)
- `main()`  (L229)
- `qpsk_indexer(K, sym, M)`  (L17)

## scripts/qpsk_end2end_golden.py
- `count_twoq(tqc)`  (L20)
- `iqft_gate(n)`  (L7)
- `main()`  (L29)
- `qpsk_indexer(K, sym, M)`  (L11)

## scripts/qpsk_preflight_and_run.py
- `build_phase_integer_circuit(SYM, K, M)` — Prepare a phase-gradient then collapse to |SYM> with inverse-QFT.  (L7)
- `extract_counts_primitive_result(job)` — Robustly extract counts for SamplerV2 PrimitiveResult:  (L28)
- `hdist(a, b, M)`  (L25)
- `main()`  (L60)

## series_bessel.py
- `J0_maclaurin_coeff(n)`  (L17)
- `Jnu_maclaurin_coeff(n, nu)` — Coefficient of x^n in:  (L5)

## series_encoding.py
- `_as_complex(vec)`  (L25)
- `_catalan_value(terms)`  (L170)
- `_champernowne10_value(digits)`  (L189)
- `_e_value(terms)`  (L144)
- `_exp_pi_value(_)`  (L177)
- `_gamma_value(terms)`  (L163)
- `_gelfond_value(_)`  (L180)
- `_l2_normalize(v)`  (L21)
- `_liouville_value(terms)`  (L183)
- `_ln2_value(terms)`  (L151)
- `_pad_truncate(v, N)`  (L577)
- `_parse_complex_token(zstr)`  (L37)
- `_parse_polylog(label)`  (L47)
- `_phi_value(_)`  (L167)
- `_pi_value(terms, method)`  (L92)
- `_polylog_series(s, z, terms, tol)` — Li_s(z) = Σ_{n≥1} z^n / n^s. Direct series with simple guards.  (L56)
- `_qte_apply_egf_weights(vec)`  (L982)
- `_QTE_apply_rail(vec)`  (L1179)
- `_qte_auto_radius(expr)`  (L1381)
- `_QTE_Bern(n)`  (L1622)
- `_QTE_BernPoly(n, x)`  (L1624)
- `_qte_bessel_Jn_terms(n, N)`  (L1453)
- `_qte_bessel_Jn_value(n, x, terms, tol)` — Stable J_n(x) via term ratio:  (L1466)
- `_QTE_bessel_Jn_value(n, x, terms)`  (L1541)
- `_qte_bessel_terms_vector(n, dim)` — Return first `dim` Maclaurin coefficients of J_n(x).  (L1502)
- `_QTE_compute_series_value_anys(label, terms, method)`  (L1774)
- `_qte_detect_rail_and_strip(lbl)`  (L965)
- `_qte_eta(s, terms)`  (L837)
- `_qte_eval_expr(expr, x)`  (L671)
- `_qte_eval_expr(expr, x)`  (L949)
- `_qte_eval_polylog(sv, z, terms)`  (L772)
- `_qte_eval_polylog(s, z, terms)`  (L874)
- `_qte_eval_polylog(s, z, terms)`  (L1713)
- `_QTE_eval_polylog_int(n, z, terms)`  (L1698)
- `_qte_eval_zeta_int(k, terms)`  (L736)
- `_qte_expr_preproc(expr)`  (L667)
- `_QTE_get_series_amplitudes_safe(label, dim, method, phase_mode, normalize, amp_mode)`  (L1202)
- `_QTE_has_rail(lbl)`  (L1173)
- `_qte_is_maclaurin_label(lbl)`  (L646)
- `_QTE_is_rail(lbl)`  (L1150)
- `_QTE_j0_terms_vector(n)`  (L1191)
- `_qte_j0_vector(dim, egf, phase_mode, normalize)`  (L905)
- `_QTE_log_branch(z)`  (L1743)
- `_QTE_log_p(z)`  (L1634)
- `_qte_maclaurin_coeffs(expr, n_terms, radius, m)`  (L682)
- `_qte_maclaurin_coeffs(expr, n_terms, radius, m)`  (L1426)
- `_QTE_ORIG_compute_series_value(label, terms, method)`  (L714)
- `_qte_parse_bessel_label(lbl)`  (L1081)
- `_QTE_parse_Jn_value(lbl)`  (L1530)
- `_qte_parse_maclaurin(lbl)`  (L649)
- `_qte_parse_maclaurin(lbl)`  (L1395)
- `_qte_parse_polylog_label(t)`  (L747)
- `_qte_parse_polylog_label(label)`  (L855)
- `_qte_parse_polylog_label_qte(lbl)`  (L1798)
- `_qte_parse_qft_label(lbl)`  (L991)
- `_qte_parse_zeta_label(label)`  (L814)
- `_qte_polylog_alt_realneg(s, z, terms)`  (L1321)
- `_QTE_polylog_any_s(z, s, terms)`  (L1755)
- `_qte_polylog_euler(s, z, terms)`  (L1097)
- `_qte_polylog_euler_alt(s, z, terms)`  (L1826)
- `_qte_polylog_eval(s, z, terms)`  (L1843)
- `_qte_polylog_integer_cont(s, z, terms)`  (L1340)
- `_QTE_polylog_inversion_int(n, z, terms)`  (L1688)
- `_qte_polylog_known(s, z)`  (L1362)
- `_QTE_polylog_mu_expansion_int(n, z, K)`  (L1667)
- `_qte_polylog_power(s, z, terms)`  (L1315)
- `_qte_polylog_series(s, z, terms)`  (L1813)
- `_QTE_polylog_series_int(n, z, terms)`  (L1655)
- `_QTE_polylog_series_int(n, z, terms)`  (L1750)
- `_QTE_PREV_compute_series_value(label, terms, method)`  (L733)
- `_qte_qft_amplitudes(expr, dim, a, b, use_ifft)`  (L1014)
- `_qte_split_rails(vec)`  (L973)
- `_QTE_strip_rail(lbl)`  (L1156)
- `_QTE_strip_rail(lbl)`  (L1176)
- `_qte_value_zeta_int(k, terms)`  (L844)
- `_QTE_zeta_at_neg_int(m)`  (L1637)
- `_qte_zeta_even_2n(kk)`  (L828)
- `_QTE_zeta_value(s)`  (L1642)
- `_schmidt_entropy_bits(state, cut)` — Von Neumann entropy (bits) for bipartition [0..cut-1] vs [cut..n-1] of |ψ⟩.  (L614)
- `_terms_catalan(dim)`  (L414)
- `_terms_e(dim)`  (L384)
- `_terms_gamma(dim)`  (L404)
- `_terms_J0(dim)`  (L334)
- `_terms_ln2(dim)`  (L391)
- `_terms_phi(dim)`  (L407)
- `_terms_pi(dim, method)`  (L340)
- `_terms_zeta2(dim)`  (L398)
- `_terms_zeta3(dim)`  (L401)
- `_zeta2_value(terms)`  (L157)
- `_zeta3_value(terms)`  (L160)
- `build_sbrv(a, L, base_step)` — Greedy residual quantization with dyadic-like steps:  (L519)
- `compute_series(label, terms, method)`  (L492)
- `compute_series_value(label, terms, method)`  (L209)
- `compute_series_value(label, terms, method)`  (L716)
- `compute_series_value(label, terms, method)`  (L783)
- `compute_series_value(label, terms, method)`  (L891)
- `compute_series_value(label, terms, method)`  (L1126)
- `compute_series_value(label, terms, method)`  (L1574)
- `compute_series_value(label, terms, method)`  (L1887)
- `decode_srd_iq(re_rail, im_rail)` — Reconstruct original real values from SRD/IQ rails.  (L509)
- `encode_srd_iq(a)` — Pack real signal a into complex: real = positive rail, imag = positive of negative rail.  (L499)
- `get_series_amplitudes(label, dim, method, phase_mode, normalize, amp_mode)` — Returns exactly 'dim' amplitudes.  (L436)
- `get_series_amplitudes(label, dim, method, phase_mode, normalize, amp_mode)`  (L697)
- `get_series_amplitudes(label, dim, method, phase_mode, normalize, amp_mode)`  (L804)
- `get_series_amplitudes(label, dim, method, phase_mode, normalize, amp_mode)`  (L932)
- `get_series_amplitudes(label, dim, method, phase_mode, normalize, amp_mode)`  (L1034)
- `J0_maclaurin_coeff(n)`  (L331)
- `Jnu_maclaurin_coeff(n, nu)` — J_ν(x) = Σ_{m≥0} (-1)^m / (m! Γ(m+ν+1)) * (x/2)^{2m+ν}  (L320)
- `qte_cache_clear()`  (L1301)
- `qte_cache_clear()`  (L1597)
- `qte_cache_enable(flag)`  (L1299)
- `qte_cache_enabled()`  (L1594)
- `qte_extras_encode(coeffs, n_qubits, srd_mode, sbrv_levels)` — Pipeline:  (L583)
- `qte_extras_metrics(state, n_qubits, cut)` — Convenience metrics for quick dashboards & tests.  (L631)
- `reconstruct_sbrv(a0, stack, M)` — Reconstruct with first M levels (M≥1 includes a0). M may exceed stack length.  (L539)
- `spectral_entropy_fft(vec)` — Shannon entropy (bits) of normalized FFT power spectrum (exclude zeros).  (L553)
- `spectral_flatness_fft(vec, eps)` — Spectral flatness (geometric mean / arithmetic mean) of FFT power.  (L565)

## series_preserving.py
- `build_series_state(A, B, N, amp_mode, phase_mode, op)` — Compose a state from one or two series sources, with a chosen algebraic operation.  (L198)
- `cauchy_product(a, b)` — OGF Cauchy product: c_n = sum_{k=0}^n a_k b_{n-k}.  (L79)
- `dirichlet_convolution(a, b)` — Dirichlet convolution on indices starting at 1:  (L102)
- `egf_product(a, b)` — EGF product: c_n = sum_{k=0}^n C(n,k) a_k b_{n-k}.  (L89)
- `hadamard_product(a, b)` — Termwise product: c_n = a_n * b_n.  (L73)
- `hadamard_test_expectation(vec, mask)` — Analytic expectation value of a diagonal ±1 observable D for state |ψ⟩ with amplitudes vec:  (L182)
- `lcu_combine(vectors, coeffs, normalize_out)` — Linear Combination of Unitaries (here: just linear combination of vectors).  (L123)
- `make_diag_mask(mask, N)` — Build a ±1 diagonal mask in array form.  (L149)
- `series_vector(label, N, method, amp_mode, phase_mode, normalize)` — Return a complex vector v[0:N] representing the first N coefficients (or EGF-scaled coefficients),  (L24)
- `to_statevector(vec)` — Wrap a normalized vector as a qiskit Statevector if available; else return the numpy array.  (L57)

## sign_split_register.py
- `_l2_norm(v)`  (L12)
- `_norm_or_zero(v)`  (L15)
- `decode_srd_iq(real_part, imag_part)` — Given phase-aware estimates of Re(c), Im(c): reconstruct a = p - n.  (L40)
- `encode_srd_ancilla(a, alpha, beta)` — Phase-insensitive SRD (ancilla-tag) spec:  (L19)
- `encode_srd_iq(a)` — Phase-aware SRD (I/Q) packing: c = p + i n  with a = p - n.  (L31)
- `sign_split(a)` — Elementwise decompose a real sequence a into nonnegative rails p, n such that a = p - n.  (L5)

## smoke_test.py
- `main()`  (L6)

## special_values_table.py
- `realish(z)`  (L18)

## state_io.py
- `_suggest_name(label, n_qubits, data)`  (L18)
- `load_statevector_dialog(parent)` — Native open dialog (macOS-safe). Returns (label, Statevector) or None.  (L62)
- `save_statevector(sv, label, out_dir)` — Non-dialog fallback: write into ./states/  (L27)
- `save_statevector_dialog(parent, sv, label)` — Native save dialog (macOS-safe). Returns path or None if cancelled.  (L37)

## sweep_polylog.py

## tests/test_fft_invariants.py
- `assert_equiv(name, x, **opts)` — Compare QTE transform to explicit reference. Returns bool.  (L63)
- `check_peaks(name, x, expect_peaks, peak_tol_bins, exclude_radius, **opts)` — Peak-based behavior check, pad-aware.  (L76)
- `main()`  (L97)
- `nearly_zero_spectrum(P, atol)`  (L60)
- `nms_peaks(power, k, exclude_radius)` — Greedy non-maximum suppression peak picker.  (L48)
- `reference_dollarhide_spectrum(x, remove_dc, window, pad_len)`  (L5)

## tests_qte.py
- `test_bessel_values()`  (L22)
- `test_j0_egf_finite()`  (L6)
- `test_maclaurin_syntax()`  (L27)
- `test_polylog_core()`  (L15)
- `test_qft_rail_norm()`  (L10)
