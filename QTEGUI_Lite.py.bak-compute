
import json, math
from typing import Optional, Dict, Any
try:
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox
except Exception:  # headless import fallback
    import types as _t
    tk = _t.SimpleNamespace(Frame=object)
    ttk = _t.SimpleNamespace(Frame=object)
    filedialog = messagebox = None

import numpy as np

# Optional deps
try:
    from entropy_lab import (
        entropy_certificate_pack,
        entropy_certificate_verify,
    )
except Exception:
    entropy_certificate_pack = None
    entropy_certificate_verify = None

try:
    # Prefer the local repo's tools/demo_payload_flow.py (avoids 3p 'tools' package collisions)
    import importlib.util, sys, pathlib
    _p = pathlib.Path(__file__).with_name('tools').joinpath('demo_payload_flow.py')
    if _p.exists():
        _spec = importlib.util.spec_from_file_location('demo_payload_flow_local', str(_p))
        _mod = importlib.util.module_from_spec(_spec); sys.modules[_spec.name] = _mod
        _spec.loader.exec_module(_mod)
    else:
        from tools import demo_payload_flow as _mod
    int_to_basis_amplitudes = _mod.int_to_basis_amplitudes
    scramble_amplitudes    = _mod.scramble_amplitudes
    unscramble_amplitudes  = _mod.unscramble_amplitudes
    capacity_bits          = _mod.capacity_bits
except Exception:
    import numpy as np
    def int_to_basis_amplitudes(n, v):
        n = int(n); d = 1 << n
        a = np.zeros(d, dtype=complex)
        a[int(v) % d] = 1.0
        return a
    def scramble_amplitudes(a, key):
        return a, {'perm': None, 'phases': None}
    def unscramble_amplitudes(a, params):
        return a
    def capacity_bits(n):
        n = int(n)
        return {'bits_per_register_plain': n, 'bits_per_register_superdense': 2*n}




class EntropyTab(ttk.Frame):
    """
    Minimal functional tab:
      - holds a current amplitude vector self.a (defaults to |0...0> for n=6)
      - save_certificate(path) -> writes JSON cert
      - verify_certificate(path, atol_bits=1e-6) -> (ok, info)
    UI is intentionally tiny; methods are callable by the menu.
    """
    def __init__(self, master, n:int=6):
        super().__init__(master)
        self.n = int(n)
        self.d = 1 << self.n
        self.a = np.zeros(self.d, complex); self.a[0] = 1.0
        if hasattr(self, "_build_ui"):
            self._build_ui()

    def _build_ui(self):
        lbl = ttk.Label(self, text=f"Entropy tab ready (n={self.n}, d={self.d}).")
        lbl.pack(anchor="w", padx=8, pady=8)

    # --- API ---
    def save_certificate(self, path: Optional[str]=None) -> Optional[str]:
        if entropy_certificate_pack is None:
            return None
        cert = entropy_certificate_pack(self.a)
        if path is None and 'filedialog' in globals() and filedialog:
            path = filedialog.asksaveasfilename(defaultextension=".json",
                                                filetypes=[("JSON","*.json")],
                                                title="Save entropy certificate")
        if not path:
            return None
        with open(path, "w") as f:
            json.dump(cert, f, indent=2)
        return path

    def verify_certificate(self, path: str, atol_bits: float=1e-6):
        if entropy_certificate_verify is None:
            return False, {"error":"entropy_certificate_verify unavailable"}
        try:
            ref = json.load(open(path, "r"))
        except Exception as e:
            return False, {"error": f"load failed: {e}"}
        ok, info = entropy_certificate_verify(self.a, ref, atol_bits=atol_bits)
        return bool(ok), info


class SpectrumTab(ttk.Frame):
    """
    Minimal spectrum tab:
      - spectrum(a) -> dict with power, flatness, H_z, H_qft
    """
    def __init__(self, master):
        super().__init__(master)
        if hasattr(self, "_build_ui"):
            self._build_ui()

    def _build_ui(self):
        ttk.Label(self, text="Spectrum tab ready.").pack(anchor="w", padx=8, pady=8)

    def spectrum(self, a: np.ndarray) -> Dict[str, Any]:
        a = np.asarray(a, complex).reshape(-1)
        if a.size == 0: return {"error":"empty"}
        a = a / (np.linalg.norm(a) or 1.0)
        pz = (np.abs(a)**2).astype(float)
        Hz = float(-(pz[pz>0]*np.log2(pz[pz>0])).sum()) if np.any(pz>0) else 0.0
        F = np.fft.fft(a) / math.sqrt(a.size)
        pf = (np.abs(F)**2).astype(float)
        Hf = float(-(pf[pf>0]*np.log2(pf[pf>0])).sum()) if np.any(pf>0) else 0.0
        P = np.abs(np.fft.fft(a))**2
        S = float(P.sum()) or 1.0
        flat = float(np.exp(np.mean(np.log((P+1e-15)/S))) / np.mean(P/S))
        return {"H_Z_bits":Hz, "H_QFT_bits":Hf, "flatness":flat, "len":int(a.size)}


class PayloadTab(ttk.Frame):
    """
    Minimal payload demo:
      - run_demo(n, v, key, tamper=False) -> summary dict
    """
    def __init__(self, master):
        super().__init__(master)
        if hasattr(self, "_build_ui"):
            self._build_ui()

    def _build_ui(self):
        ttk.Label(self, text="Payload tab ready.").pack(anchor="w", padx=8, pady=8)

    def run_demo(self, n:int=6, v:int=13, key:bytes=b"key", tamper:bool=False):
        if None in (int_to_basis_amplitudes, scramble_amplitudes, unscramble_amplitudes, capacity_bits, entropy_certificate_pack, entropy_certificate_verify):
            return {"error": "dependencies missing"}
        a = int_to_basis_amplitudes(n, v)
        cert = entropy_certificate_pack(a)
        a_scr, params = scramble_amplitudes(a, key)
        if tamper and a_scr.size >= 1:  # small deterministic nudge
            a_scr[0] *= -1
        a_back = unscramble_amplitudes(a_scr, params)
        ok, info = entropy_certificate_verify(a_back, cert, atol_bits=1e-9)
        cap = capacity_bits(n)
        return {
            "verify_ok": bool(ok),
            "verify_info": info,
            "capacity": cap,
            "n": int(n),
            "d": int(1<<n),
            "v": int(v),
        }
