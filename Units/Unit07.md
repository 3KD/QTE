# Unit 07 — Atlas / Similarity Geometry / Semantic Neighborhoods

## SCOPE / PURPOSE

Unit 07 is where we stop thinking "one ψ at a time" and start thinking
"the geometry of all ψ we care about."

We build an ATLAS:
- a collection of canonical ψ (from Unit 01 NVE),
- their deterministic similarity relationships,
- and an embedding of those relationships into a lower-dimensional
  "neighborhood map" (2D / 3D coordinates, clusters, labels).

This is how we say:
"sin(x) lives here, cos(x) lives nearby, Ramanujan π expansion lives over here,
and this encrypted payload ψ' sits way over in that corner so don't claim
it's 'basically sin' because it's obviously not."

The ATLAS is how we do fingerprinting, clustering, semantic lookup, and
"show me nearest neighbors" — both for math objects and for payload states.

This unit defines:
- how we compute pairwise similarity;
- how we guarantee symmetry / determinism in those similarity scores;
- how we turn a batch of ψ states and those pairwise scores into a stable,
  signed ATLAS artifact we can ship around / refer to in papers / audit logs.

We do **not** invent new ψ here. We ONLY consume canonical ψ from Unit 01.

We do **not** loosen determinism. If you regenerate the ATLAS for the same
set of ψ inputs, you MUST get bit-for-bit identical similarity matrix and
identical serialized ATLAS coordinates, or the run is considered invalid.

Downstream units (24, 26, 27) will lean on this ATLAS to argue about
semantic distance, distinguishability hardness, and witness space coverage.

## INPUTS

Unit 07 consumes:

1. Canonical ψ vectors:
   - Generated by `nve-build` (Unit 01), with `nve_version="Unit01"`,
     `endianness="little"`, and `qft_kernel_sign="+"`.
   - Each ψ has:
     * ψ.npy        (L2-normalized; ||ψ||₂ ≈ 1e-12, no NaN/Inf)
     * ψ.meta.json  (must include: nve_version, weighting_mode,
                     phase_mode, rail_mode, endianness="little",
                     qft_kernel_sign="+", and deterministic
                     psi_fingerprint / semantic_hash)

2. A manifest declaring which ψ objects we're loading into the ATLAS:
   - e.g. "Maclaurin[sin(x)] N=64 egf full_complex iq_split",
         "Maclaurin[cos(x)] N=64 egf full_complex iq_split",
         "RamanujanPi ...",
         "payload:QPSK_ibm_torino_M256_sym145_8b_512s ...",
         etc.
   - This manifest MUST be explicit, not implied.
   - The manifest MUST freeze ordering. Order matters because we will
     build a similarity matrix indexed in that order, and a coordinate list
     in that same order.
   - The manifest becomes part of the serialized ATLAS output.
   - Anyone rebuilding the ATLAS MUST use the exact same manifest in the
     same order to get a byte-identical result.

3. Symmetric similarity function:
   - Provided by `nve-similarity` (declared in Unit 01 CLI and tested in
     test_unit01_contract_cli.py).
   - The contract from Unit 01 says:
        "nve-similarity" exists
        and we enforce "similarity symmetry tolerance 1e-12"
     which means:
        similarity(ψ_a, ψ_b) and similarity(ψ_b, ψ_a)
        MUST match within 1e-12.
   - Violating that is illegal. If that symmetry check fails, ATLAS
     construction MUST refuse to continue.
   - We usually take cosine similarity on normalized ψ, which equals
     real(<ψ_a · ψ_b*>) if they’re complex. But the precise formula must
     be declared and frozen. We DO NOT silently switch metrics.

So: Unit 07 assumes we can, for any pair (i,j) in the manifest,
call `nve-similarity --a psi_i.npy --b psi_j.npy --metric cosine`
and get a deterministic scalar s_ij
with s_ij ≈ s_ji within 1e-12.

## OUTPUTS

Unit 07 produces TWO artifacts:

1. `atlas_similarity_matrix.json`
   - square matrix S[i][j] of similarities
   - MUST be symmetric within 1e-12
   - MUST be deterministic bit-for-bit for a fixed manifest
   - MUST include metadata block:

        {
          "atlas_version": "Unit07",
          "nve_version": "Unit01",
          "similarity_metric": "cosine",
          "symmetry_tolerance": 1e-12,
          "endianness": "little",
          "qft_kernel_sign": "+",
          "manifest": [
            { "psi_label": "...", "psi_fingerprint": "...", "semantic_hash": "..." },
            ...
          ],
          "S": [
            [1.0, 0.123, ...],
            [0.123, 1.0, ...],
            ...
          ]
        }

   - `atlas_version` MUST be the literal string "Unit07".
   - `nve_version` MUST be "Unit01".
   - We MUST repeat `endianness="little"` and `qft_kernel_sign="+"` here
     to keep global consistency visible.
   - We MUST carry each ψ entry’s `psi_fingerprint` and `semantic_hash`.
     This proves which exact ψ states we compared.

   If any ψ metadata is missing, or if any row/col fails symmetry,
   Unit 07 MUST abort instead of outputting a matrix.

2. `atlas_layout.json`
   - deterministic low-dim embedding / coordinates derived from the matrix.
   - MUST include:

        {
          "atlas_version": "Unit07",
          "embedding_algo": "FIXED_LINEAR_MAP_V1",
          "coords": [
            { "psi_label": "...", "x": <float>, "y": <float> },
            ...
          ],
          "symmetry_tolerance": 1e-12,
          "similarity_metric": "cosine",
          "endianness": "little",
          "qft_kernel_sign": "+",
          "nve_version": "Unit01"
        }

   Rules:
   - The dimensionality (2D vs 3D) MUST be declared.
     Here we are freezing "2D" and calling it "x", "y".
     If someone wants 3D later they MUST bump
     embedding_algo and/or atlas_version.

   - The embedding algorithm MUST be a deterministic function
     of the similarity matrix and MUST include a literal algorithm tag
     (here "FIXED_LINEAR_MAP_V1"). Absolutely no random seeds,
     no nondeterministic SVD ordering w/out canonicalization, etc.
     If the linear algebra requires sign fixing or axis flip fixing,
     that rule MUST be explicit and MUST be repeatable.

   - The ordering in "coords" MUST match the manifest order, 1:1.

If any of these determinism rules are broken, the ATLAS is invalid and
cannot be published.

## WHY THIS EXISTS

Why do we need a frozen "atlas_version" = "Unit07"?

- Because later units (24, 26, 27) are going to point to an ATLAS and say:
  "See that blob? That blob corresponds to THIS class of states, and here
  are the hardness assumptions / uniqueness claims / IP claims."

- If ATLAS can drift (reordering manifest, changing similarity metric,
  not preserving 1e-12 symmetry tolerance, etc.) then those proofs/snapshots
  don't mean anything because you can't prove "this blob in October is
  the same blob in December."

- By stamping atlas_version="Unit07" we lock semantic geometry format.

Why do we repeat global conventions (`endianness="little"`,
`qft_kernel_sign="+"`, `nve_version="Unit01"`) in ATLAS output?

- Because "semantic similarity" is only meaningful if all ψ obey the
  same canonical interpretation of basis index and QFT sign.
- If someone tries to sneak in a ψ that was built with the wrong sign
  or reversed bit order, but pretends it's legit, we can catch them
  by inspecting the fingerprints, the loader metadata, and the claimed
  NVE version.

## CONTRACT (DO NOT CHANGE)

pytest for Unit 07 will grep this exact block for required tokens.
If you edit/remove these literals without updating tests and bumping
the version, pytest will fail and you will not be allowed to push.

Required substrings that MUST appear in this file:

    atlas_version": "Unit07"
    nve_version": "Unit01"
    endianness": "little"
    qft_kernel_sign": "+"
    similarity_metric": "cosine"
    symmetry_tolerance": 1e-12
    psi_fingerprint
    semantic_hash
    manifest
    S":
    atlas_similarity_matrix.json
    atlas_layout.json
    embedding_algo": "FIXED_LINEAR_MAP_V1"
    coords
    x":
    y":
    nve-similarity
    similarity symmetry tolerance 1e-12

The ATLAS MUST be deterministic, manifest-order-stable,
and MUST refuse to proceed if `nve-similarity` detects
that similarity(ψ_a, ψ_b) != similarity(ψ_b, ψ_a)
within the 1e-12 tolerance we froze in Unit 01.

Those phrases are not negotiable. They ARE the contract.
