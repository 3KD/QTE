from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

# --- Tomography availability guard ---
try:
    from qiskit_experiments.library import StateTomography
    from qiskit.quantum_info import state_fidelity, DensityMatrix
    try:
        from qiskit_aer import AerSimulator
    except Exception:
        AerSimulator = None
    from qiskit import Aer
    TOMO_OK = True
except Exception:
    StateTomography = None
    state_fidelity = None
    DensityMatrix = None
    AerSimulator = None
    try:
        from qiskit import Aer
    except Exception:
        Aer = None
    TOMO_OK = False


from tkinter import filedialog, messagebox

def _qte_call(tab, name, *args, **kw):
    fn = getattr(tab, name, None)
    if not callable(fn):
        raise AttributeError(f"{tab} has no callable '{name}'")
    return fn(*args, **kw)



# Tabs (transitional)
try:
    from QTEGUI_Lite import EntropyTab, SpectrumTab, PayloadTab
except Exception:
    EntropyTab = SpectrumTab = PayloadTab = None
# QTEGUI — header reset (auto-fix)\nfrom __future__ import annotations\n\nimport sys, os, re, math, json, pathlib\nfrom typing import *\nimport numpy as np\ntry:\n    import matplotlib.pyplot as plt  # optional\nexcept Exception:\n    plt = None\n\n# == OPTIONAL IMPORTS (QTE) ==\ntry:\n    import entropy_lab  # entropy certificates / MUB checks\nexcept Exception:\n    entropy_lab = None\n\ntry:\n    import harmonic_analysis  # FFT spectrum helpers\nexcept Exception:\n    harmonic_analysis = None\n\ntry:\n    from quantum_embedding import (\n        perform_schmidt_decomposition,\n        simulate_statevector,\n    )\nexcept Exception:\n    perform_schmidt_decomposition = None\n    simulate_statevector = None\n# == END OPTIONAL IMPORTS ==\n\n# --- Tk imports (safe) ---\ntry:\n    import tkinter as tk\n    from tkinter import ttk\n    from tkinter.constants import MULTIPLE, END\nexcept Exception:\n    # Provide light stubs so the module can still import without Tk.\n    import types as _types\n    tk = _types.SimpleNamespace(Toplevel=object, Listbox=object, END=None)\n    ttk = _types.SimpleNamespace(Frame=object, Label=object, Button=object)\n    MULTIPLE = None\n    END = None\n\n\n\n# --- NEW: labels restricted to Terms only (e.g., J0) ---\ndef _is_terms_only(label: str) -> bool:\n    """Return True if this label only supports Terms mode (not EGF)."""\n    return _norm_label(label) in {"J0"}\n\ndef _split_top_level(s: str) -> List[str]:\n    out, depth, buf = [], 0, []\n    for ch in s:\n        if ch == '(':\n            depth += 1\n        elif ch == ')':\n            depth = max(0, depth - 1)\n        if ch == ',' and depth == 0:\n            token = ''.join(buf).strip()\n            if token:\n                out.append(token)\n            buf = []\n        else:\n            buf.append(ch)\n    token = ''.join(buf).strip()\n    if token:\n        out.append(token)\n    return out\n\ndef _parse_constants_syntax(s: str) -> List[Tuple[str, Optional[str]]]:\n    """\n    Grammar (informal):\n      token := LABEL [ "(" ARGS ")" ] [ "(" METHOD ")" ]?\n    Only π/pi consumes METHOD (Leibniz, Nilakantha, Machin, Ramanujan, Chudnovsky).\n    """\n    parts = _split_top_level(s)\n    out: List[Tuple[str, Optional[str]]] = []\n    for raw in parts:\n        t = raw.strip()\n        if not t:\n            continue\n\n        # locate outermost trailing "(...)"\n        depth, last_open, last_close = 0, -1, -1\n        for i, ch in enumerate(t):\n            if ch == '(':\n                if depth == 0:\n                    last_open = i\n                depth += 1\n            elif ch == ')':\n                depth -= 1\n                if depth == 0:\n                    last_close = i\n        if depth != 0:\n            raise ValueError(f"Unbalanced parentheses in: {t}")\n\n        label, method = t, None\n\n        if last_open != -1 and last_close == len(t) - 1:\n            inside = t[last_open + 1:last_close].strip()\n            before = t[:last_open].strip()\n            if inside.lower() in KNOWN_METHODS and _supports_method(before or t):\n                label = before or t\n                method = inside\n            else:\n                label = t  # parentheses belong to label (e.g., Li(2,0.5))\n\n        label = _norm_label(label)\n\n        if _supports_method(label):\n            method = _canonical_method(label, method)\n        else:\n            method = None\n\n        out.append((label, method))\n    return out\n\ndef _constants_to_syntax(pairs: List[Tuple[str, Optional[str]]]) -> str:\n    toks = []\n    for lab, meth in pairs:\n        lab = _norm_label(lab)\n        if meth and _supports_method(lab):\n            toks.append(f"{lab}({meth})")\n        else:\n            toks.append(lab)\n    return ", ".join(toks)\n\nclass ConstantPicker(tk.Toplevel):\n    def __init__(self, master, initial: List[Tuple[str, Optional[str]]]):\n        super().__init__(master)\n        self.title("Pick constants")\n        self.resizable(False, False)\n        self.transient(master)\n        self.grab_set()\n\n        self._selected: Dict[str, Optional[str]] = {_norm_label(lab): meth for lab, meth in initial}\n\n        body = ttk.Frame(self, padding=8)\n        body.pack(fill="both", expand=True)\n\n        left = ttk.Frame(body)\n        left.grid(row=0, column=0, sticky="nsw", padx=(0,10))\n        right = ttk.Frame(body)\n        right.grid(row=0, column=1, sticky="nse")\n\n        ttk.Label(left, text="Constants").pack(anchor="w")\n\n        self.box = tk.Listbox(left, selectmode=MULTIPLE, height=12, exportselection=False, width=28)\n        for lab in SUGGESTED_LABELS:\n            self.box.insert("end", lab)\n        self.box.pack()\n        self.box.bind("<<ListboxSelect>>", self._on_select)\n\n        for i, lab in enumerate(SUGGESTED_LABELS):\n            if _norm_label(lab) in self._selected:\n                self.box.selection_set(i)\n\n        addrow = ttk.Frame(left); addrow.pack(fill="x", pady=(8,0))\n        self.custom_var = tk.StringVar(value="")\n        ttk.Entry(addrow, textvariable=self.custom_var, width=20).pack(side="left")\n        ttk.Button(addrow, text="Add", command=self._add_custom).pack(side="left", padx=4)\n\n        ttk.Label(right, text="Method (for highlighted π)").grid(row=0, column=0, sticky="w")\n        self.method_var = tk.StringVar(value="")\n        self.method_combo = ttk.Combobox(right, textvariable=self.method_var, state="disabled",\n                                         values=METHOD_CHOICES.get("π", []), width=18)\n        self.method_combo.grid(row=1, column=0, sticky="w", pady=(2,8))\n        ttk.Button(right, text="Set Method", command=self._apply_method).grid(row=2, column=0, sticky="w")\n\n        btns = ttk.Frame(body); btns.grid(row=1, column=0, columnspan=2, sticky="e", pady=(10,0))\n        ttk.Button(btns, text="OK", command=self._ok).pack(side="right", padx=6)\n        ttk.Button(btns, text="Cancel", command=self._cancel).pack(side="right")\n\n        self.result: Optional[List[Tuple[str, Optional[str]]]] = None\n\n    def _on_select(self, _evt=None):\n        sel = self._current_highlight()\n        if sel and _supports_method(sel):\n            self.method_combo.config(state="readonly", values=METHOD_CHOICES.get(_norm_label(sel), []))\n            self.method_var.set(self._selected.get(_norm_label(sel)) or _canonical_method(sel, None))\n        else:\n            self.method_combo.config(state="disabled")\n            self.method_var.set("")\n\n    def _current_highlight(self) -> Optional[str]:\n        idxs = self.box.curselection()\n        if not idxs:\n            return None\n        return _norm_label(self.box.get(idxs[0]).strip())\n\n    def _apply_method(self):\n        sel = self._current_highlight()\n        if not sel or not _supports_method(sel):\n            return\n        meth = self.method_var.get().strip()\n        if not meth:\n            meth = _canonical_method(sel, None)\n        self._selected[sel] = _canonical_method(sel, meth)\n\n    def _add_custom(self):\n        lab = _norm_label(self.custom_var.get().strip())\n        if not lab:\n            return\n        self._selected.setdefault(lab, _canonical_method(lab, None))\n        self.box.insert("end", lab)\n        self.custom_var.set("")\n\n    def _ok(self):\n        final: List[Tuple[str, Optional[str]]] = []\n        for i in self.box.curselection():\n            lab = _norm_label(self.box.get(i).strip())\n            final.append((lab, self._selected.get(lab)))\n        self.result = final\n        self.destroy()\n\n    def _cancel(self):\n        self.result = None\n        self.destroy()\n\n# -----------------------------\n# GUI\n# -----------------------------\n\nclass QTEGUI(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title("Quantum Transcendental Encoder (QTE)")\n        self.geometry("1260x900")\n\n        self.statevectors: Dict[str, Statevector] = {}\n        self.active_state_label: Optional[str] = None\n        self.active_state: Optional[Statevector] = None\n\n        # -------- Top controls --------\n        top = ttk.Frame(self); top.pack(fill="x", padx=10, pady=8)\n\n        # NEW: constants syntax + picker\n        ttk.Label(top, text="Constant(s)").grid(row=0, column=0, sticky="w")\n        self.const_syntax = tk.StringVar(value="π")\n        ttk.Entry(top, textvariable=self.const_syntax, width=36).grid(row=0, column=1, padx=(4,6))\n        ttk.Button(top, text="Pick…", command=self.on_pick_constants).grid(row=0, column=2, padx=(0,12))\n\n        # π method (convenience default if single π without explicit method)\n        self.pi_method = tk.StringVar(value="Machin")\n        ttk.Label(top, text="π method").grid(row=0, column=3, sticky="w")\n        ttk.Combobox(top, textvariable=self.pi_method,\n                     values=METHOD_CHOICES["π"], state="readonly", width=12).grid(row=0, column=4, padx=(4, 12))\n\n        self.phase_mode = tk.StringVar(value="sign")\n        ttk.Label(top, text="Phase").grid(row=0, column=5, sticky="w")\n        ttk.Combobox(top, textvariable=self.phase_mode,\n                     values=["sign", "abs"], state="readonly", width=6).grid(row=0, column=6, padx=(4, 12))\n\n        self.n_qubits = tk.IntVar(value=6)\n        ttk.Label(top, text="#qubits").grid(row=0, column=7, sticky="w")\n        ttk.Spinbox(top, from_=1, to=14, textvariable=self.n_qubits, width=5).grid(row=0, column=8, padx=(4, 12))\n\n        self.pad_len = tk.IntVar(value=128)\n        ttk.Label(top, text="Pad (FFT)").grid(row=0, column=9, sticky="w")\n        ttk.Spinbox(top, from_=16, to=4096, increment=16, textvariable=self.pad_len, width=7).grid(row=0, column=10, padx=(4, 12))\n\n        self.use_ibm = tk.BooleanVar(value=False)\n        ttk.Checkbutton(top, text="Use IBM", variable=self.use_ibm, command=self._maybe_prompt_ibm).grid(row=0, column=11, padx=(6, 6))\n\n        # Multi controls\n        self.reg_qubits = tk.IntVar(value=3)\n        self.multi_topology = tk.StringVar(value="chain")\n        ttk.Label(top, text="RegQ").grid(row=1, column=0, sticky="e")\n        ttk.Spinbox(top, from_=1, to=8, textvariable=self.reg_qubits, width=5).grid(row=1, column=1, sticky="w")\n        ttk.Label(top, text="Topology").grid(row=1, column=2, sticky="e")\n        ttk.Combobox(top, textvariable=self.multi_topology, values=["chain","star","all_to_all"], state="readonly", width=10).grid(row=1, column=3, sticky="w")\n\n        # Encoding mode row\n        self.enc_mode = tk.StringVar(value="EGF")\n        ttk.Label(top, text="Encoding").grid(row=1, column=4, sticky="e")\n        ttk.Combobox(top, textvariable=self.enc_mode,\n                     values=["EGF", "Terms", "Periodic p/q", "Value Phase (PEA)", "Digit QROM"],\n                     state="readonly", width=16).grid(row=1, column=5, padx=(4, 12))\n\n        self.pea_bits = tk.IntVar(value=10)\n        ttk.Label(top, text="PEA bits").grid(row=1, column=6, sticky="e")\n        ttk.Spinbox(top, from_=2, to=20, textvariable=self.pea_bits, width=5).grid(row=1, column=7, padx=(4,12))\n\n        self.p_val = tk.IntVar(value=22); self.q_val = tk.IntVar(value=7)\n        ttk.Label(top, text="p/q").grid(row=1, column=8, sticky="e")\n        ttk.Spinbox(top, from_=1, to=100000, textvariable=self.p_val, width=7).grid(row=1, column=9, sticky="w")\n        ttk.Spinbox(top, from_=1, to=100000, textvariable=self.q_val, width=7).grid(row=1, column=10, sticky="w")\n\n        self.qrom_base = tk.IntVar(value=10)\n        self.qrom_bits = tk.IntVar(value=4)\n        self.qrom_index = tk.IntVar(value=6)\n        ttk.Label(top, text="QROM base/bits/index").grid(row=1, column=11, sticky="e")\n        ttk.Spinbox(top, from_=2, to=16, textvariable=self.qrom_base, width=5).grid(row=1, column=12)\n        ttk.Spinbox(top, from_=1, to=8, textvariable=self.qrom_bits, width=4).grid(row=1, column=13)\n        ttk.Spinbox(top, from_=1, to=10, textvariable=self.qrom_index, width=5).grid(row=1, column=14)\n\n        # Status line\n        self.status_var = tk.StringVar(value="Ready.")\n        ttk.Label(self, textvariable=self.status_var, anchor="w").pack(fill="x", padx=10, pady=(0, 6))\n\n        # Notebook tabs\n        self.nb = ttk.Notebook(self); self.nb.pack(fill="both", expand=True, padx=10, pady=(0, 10))\n        self._build_tab_preview()\n        self._build_tab_fft()\n        self._build_tab_qft()\n        self._build_tab_measure()\n        self._build_tab_amplitudes()\n        self._build_tab_similarity()\n        self._build_tab_clustering()\n        self._build_tab_tomography()\n        self._build_tab_entanglement()\n        self._build_tab_gates()\n        self._build_tab_state_io()\n        self._build_tab_basis()\n        self._build_tab_chunks()  # NEW\n\n    # -------- IBM init --------\n    def _maybe_prompt_ibm(self):\n        if self.use_ibm.get():\n            try:\n                token = simpledialog.askstring("IBM Login", "Enter your IBM Quantum API Token:", show="*")\n                if token:\n                    initialize_ibm(token=token)\n                    self._set_status("IBM Quantum initialized.")\n                else:\n                    self.use_ibm.set(False)\n            except Exception as e:\n                messagebox.showerror("IBM Login Failed", str(e))\n                self.use_ibm.set(False)\n\n    # -------- constants helpers --------\n    def on_pick_constants(self):\n        pairs = self._current_constants(default_if_empty=True)\n        dlg = ConstantPicker(self, pairs)\n        self.wait_window(dlg)\n        if dlg.result is not None:\n            self.const_syntax.set(_constants_to_syntax(dlg.result))\n\n    def _current_constants(self, *, default_if_empty=False) -> List[Tuple[str, Optional[str]]]:\n        s = self.const_syntax.get().strip()\n        if not s and default_if_empty:\n            s = "π"\n        try:\n            pairs = _parse_constants_syntax(s) if s else []\n        except Exception as e:\n            messagebox.showerror("Constant(s) parse error", str(e))\n            return []\n        if len(pairs) == 1 and _supports_method(pairs[0][0]) and not pairs[0][1]:\n            pairs = [(pairs[0][0], self.pi_method.get())]\n        return pairs\n\n    def _single_constant_required(self, ctx: str) -> Optional[Tuple[str, Optional[str]]]:\n        pairs = self._current_constants(default_if_empty=True)\n        if len(pairs) != 1:\n            messagebox.showinfo(ctx, f"{ctx} requires a single constant. Current selection: {len(pairs)}.\n"\n                                     f"Use Prepare/Run to build a multi-register Active state, then run {ctx} with 'Use Active'.")\n            return None\n        return pairs[0]\n\n    # -------- format/helpers --------\n    def _fmt_amp(self, a: complex) -> str:\n        return f"{a.real:+.6e}{'+' if a.imag>=0 else ''}{a.imag:.6e}j"\n\n    def _preview_multi_registers(self, pairs: List[Tuple[str, Optional[str]]], mode: str, n_each: int):\n        """Print per-register preview for multi selections."""\n        self.preview_text.insert("end", f"Multi-constant preview ({mode}). Each register: {n_each} qubits.\n\n")\n        dim_each = 2 ** n_each\n        for (lab, meth) in pairs:\n            try:\n                # Terms-only labels (e.g., J0) force terms mode for that register\n                amp_mode = "terms" if _is_terms_only(lab) else ("egf" if mode == "EGF" else "terms")\n                amps = get_series_amplitudes(\n                    lab, dim_each,\n                    method=meth,\n                    phase_mode=self.phase_mode.get(),\n                    normalize=True,\n                    amp_mode=amp_mode\n                )\n                self.preview_text.insert("end", f"{lab}{f'[{meth}]' if meth else ''} → first {min(8, dim_each)} amps:\n")\n                for i, a in enumerate(amps[:8]):\n                    self.preview_text.insert("end", f"  {i:02d}: {self._fmt_amp(a)}\n")\n                if _is_terms_only(lab) and mode != "Terms":\n                    self.preview_text.insert("end", "  (auto-used Terms for this register)\n")\n                self.preview_text.insert("end", "\n")\n            except Exception as ex:\n                self.preview_text.insert("end", f"{lab}: preview error: {ex}\n\n")\n\n    # --- Multi label parsing / entanglement helpers ---\n    def _parse_multi_label(self, label: str):\n        """Parse labels like: multi[π,e,ln(2)|chain|3] → (['π','e','ln(2)'], 'chain', 3)."""\n        if not isinstance(label, str) or not label.startswith("multi["):\n            return None\n        try:\n            inside = label.split("multi[", 1)[1]\n            regs_part, topo, tail = inside.split("|", 2)\n            regq = int(tail.split("]", 1)[0])\n            regs = [s.strip() for s in regs_part.split(",") if s.strip()]\n            return regs, topo, regq\n        except Exception:\n            return None\n\n    def _schmidt_entropy_bits(self, sv: Statevector, cut: int) -> float:\n        """Von Neumann entropy (bits) of left block of 'cut' qubits vs the rest (pure state)."""\n        try:\n            S = perform_schmidt_decomposition(sv, cut=cut)\n            p = (S ** 2)\n            p = p[p > 1e-15]\n            return float(-np.sum(p * np.log2(p)))\n        except Exception:\n            return float("nan")\n\n    def _register_marginals(self, sv: Statevector, regq: int, reg_labels: List[str]) -> List[Tuple[str, np.ndarray]]:\n        """Return per-register marginal probability vectors [2**regq] for a multi state."""\n        n = int(np.log2(len(sv.data)))\n        R = len(reg_labels)\n        probs = (np.abs(sv.data) ** 2).reshape(*([2 ** regq] * R))\n        out = []\n        for i, name in enumerate(reg_labels):\n            axes_i = tuple(j for j in range(R) if j != i)\n            m = probs.sum(axis=axes_i).reshape(-1)\n            out.append((name, m))\n        return out\n\n    def _pad_stack(self, arrays: List[np.ndarray]) -> np.ndarray:\n        """Zero-pad 1D arrays to max length and stack -> (k, m)."""\n        if not arrays:\n            return np.zeros((0, 1), dtype=float)\n        m = max(len(a) for a in arrays)\n        X = np.zeros((len(arrays), m), dtype=float)\n        for i, a in enumerate(arrays):\n            a = np.asarray(a, dtype=float).reshape(-1)\n            X[i, :len(a)] = a\n        return X\n\n    # -------- Active state helpers --------\n    def _set_active(self, label: str, sv: Statevector, also_save: bool = True):\n        self.active_state_label = label\n        self.active_state = sv\n        if also_save:\n            self.statevectors[label] = sv\n        self._refresh_all_combos()\n        self._set_status(f"Active: {label} (len={len(sv.data)})")\n\n    def _get_active_or_selected(self, combo: ttk.Combobox) -> Tuple[str, Optional[Statevector]]:\n        lbl = combo.get()\n        if lbl in self.statevectors:\n            return lbl, self.statevectors[lbl]\n        if self.active_state is not None:\n            return self.active_state_label or "[active]", self.active_state\n        return "", None\n\n    def _refresh_all_combos(self):\n        keys = list(self.statevectors.keys())\n        for cb in getattr(self, "_all_combos", []):\n            cb.config(values=keys)\n\n    def _register_combo(self, cb: ttk.Combobox):\n        if not hasattr(self, "_all_combos"):\n            self._all_combos: List[ttk.Combobox] = []\n        self._all_combos.append(cb)\n\n    def _set_status(self, msg: str):\n        if self.active_state_label:\n            self.status_var.set(f"{msg}   |   Active: {self.active_state_label}")\n        else:\n            self.status_var.set(msg)\n\n    # ================== Tab 1: Encoding Preview ==================\n    def _build_tab_preview(self):\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="Encoding Preview")\n\n        btns = ttk.Frame(tab); btns.pack(fill="x", pady=6)\n        ttk.Button(btns, text="Preview Amplitudes / Digits", command=self.on_preview_amplitudes).pack(side="left", padx=4)\n        ttk.Button(btns, text="Prepare / Run (sets Active)", command=self.on_prepare_state).pack(side="left", padx=4)\n\n        self.preview_text = tk.Text(tab, height=20)\n        self.preview_text.pack(fill="both", expand=True, padx=6, pady=6)\n\n    def on_preview_amplitudes(self):\n        try:\n            mode = self.enc_mode.get()\n            pairs = self._current_constants(default_if_empty=True)\n            n = int(self.n_qubits.get()); dim = 2 ** n\n\n            self.preview_text.delete("1.0", "end")\n\n            if len(pairs) > 1 and mode in {"EGF", "Terms"}:\n                n_each = int(self.reg_qubits.get())\n                self._preview_multi_registers(pairs, mode, n_each)\n                self.preview_text.insert("end", "Use 'Prepare / Run' to create the entangled multi-register Active state.\n")\n                return\n\n            if mode in {"EGF", "Terms"}:\n                label, method = pairs[0]\n                # Auto-switch to Terms for Terms-only labels (e.g., J0)\n                if _is_terms_only(label) and mode != "Terms":\n                    self.enc_mode.set("Terms")\n                    mode = "Terms"\n                    self._set_status(f"{label}: Terms-only — switched encoding to Terms.")\n\n                amps = get_series_amplitudes((label + "[rail]") if (rail and "[rail]" not in label.lower()) else label, dim, method=method, phase_mode=self.phase_mode.get(),\n                    normalize=True, amp_mode=("egf" if mode == "EGF" else "terms")\n                )\n                self.preview_text.insert("end", f"{label} {mode} amplitudes (first {min(64, dim)} of {dim}):\n\n")\n                for i, a in enumerate(amps[:64]):\n                    self.preview_text.insert("end", f"{i:02d}: {self._fmt_amp(a)}\n")\n                self._set_status(f"Previewed {mode} amplitudes.")\n\n            elif mode == "Digit QROM":\n                label, method = pairs[0]\n                base = int(self.qrom_base.get()); bpd = int(self.qrom_bits.get()); nidx = int(self.qrom_index.get())\n                x = compute_series_value(label, terms=2048, method=method)\n                frac = abs(x) % 1.0\n                L = 2 ** nidx\n                digits, tmp = [], frac\n                for _ in range(L):\n                    tmp *= base\n                    d = int(tmp); digits.append(d); tmp -= d\n                self.preview_text.insert("end", f"{label} digits (base {base}, first {L}):\n\n")\n                self.preview_text.insert("end", " ".join(str(d) for d in digits) + "\n")\n                self._set_status("Previewed digits for Digit QROM.")\n\n            elif mode == "Periodic p/q":\n                p, q = int(self.p_val.get()), int(self.q_val.get())\n                self.preview_text.insert("end", f"Periodic phase e^(2πi p n / q) with p={p}, q={q}, N=2^{n}.\n")\n                self.preview_text.insert("end", f"Expected QFT peaks near multiples of N/q = {2**n}/{q}.\n")\n                self._set_status("Previewed periodic parameters.")\n\n            elif mode == "Value Phase (PEA)":\n                label, method = pairs[0]\n                K = int(self.pea_bits.get())\n                x = compute_series_value(label, terms=512, method=method) % 1.0\n                self.preview_text.insert("end", f"PEA will estimate frac({label}) ≈ {x:.12f} with ~{K} bits.\n")\n                self._set_status("Previewed PEA parameters.")\n\n        except Exception as e:\n            messagebox.showerror("Preview Error", str(e))\n\n    def on_prepare_state(self):\n        try:\n            mode = self.enc_mode.get()\n            pairs = self._current_constants(default_if_empty=True)\n            n = int(self.n_qubits.get())\n\n            if len(pairs) == 1:\n                label, method = pairs[0]\n                if mode in {"EGF", "Terms"}:\n                    if _is_terms_only(label) and mode != "Terms":\n                        self.enc_mode.set("Terms")\n                        mode = "Terms"\n                        self._set_status(f"{label}: Terms-only — switched encoding to Terms.")\n\n                    sv = generate_series_encoding(\n                        label, n_qubits=n, method=method,\n                        phase_mode=self.phase_mode.get(),\n                        amp_mode=("egf" if mode == "EGF" else "terms")\n                    )\n                    key = f"{label}[{mode},{self.phase_mode.get()},{method or '-'}]({n})"\n                    self._set_active(key, sv, also_save=True)\n                    self.preview_text.delete("1.0", "end")\n                    self.preview_text.insert("end", f"Prepared Active: {key}\nlen={len(sv.data)}\n")\n\n                elif mode == "Digit QROM":\n                    base = int(self.qrom_base.get()); bpd = int(self.qrom_bits.get()); nidx = int(self.qrom_index.get())\n                    qc = digit_qrom_circuit(label, base=base, n_index=nidx, bits_per_digit=bpd, method=method, do_measure=False)\n                    sv = simulate_statevector(qc)\n                    key = f"{label}[QROM,b{base},d{bpd},L={2**nidx}]"\n                    self._set_active(key, sv, also_save=True)\n                    self.preview_text.delete("1.0", "end")\n                    self.preview_text.insert("end", f"Prepared Active: {key}\nlen={len(sv.data)}\n")\n\n                elif mode == "Periodic p/q":\n                    p, q = int(self.p_val.get()), int(self.q_val.get())\n                    qc = periodic_phase_state(p, q, n_qubits=n, do_measure=False, apply_qft=False)\n                    sv = simulate_statevector(qc)\n                    key = f"phase(p={p},q={q})[{n}]"\n                    self._set_active(key, sv, also_save=True)\n                    self.preview_text.delete("1.0", "end")\n                    self.preview_text.insert("end", f"Prepared Active: {key}\nlen={len(sv.data)}\n")\n\n                elif mode == "Value Phase (PEA)":\n                    K = int(self.pea_bits.get())\n                    qc = value_phase_estimation_circuit(label, K=K, method=method, do_measure=True)\n                    _, counts = run_circuit(qc, use_ibm=bool(self.use_ibm.get()), measure=True)\n                    self.preview_text.insert("end", "\nPEA counts (top 10):\n")\n                    if counts:\n                        for k, v in sorted(counts.items(), key=lambda kv: kv[1], reverse=True)[:10]:\n                            self.preview_text.insert("end", f"{k}: {v}\n")\n                    else:\n                        self.preview_text.insert("end", "(no counts)\n")\n                    self._set_status("Ran PEA (results shown).")\n\n            else:\n                labels = [lab for lab, _ in pairs]\n                methods = [meth for _, meth in pairs]\n                n_each = int(self.reg_qubits.get())\n                topo = self.multi_topology.get()\n                qc = entangle_series_multi(\n                    labels, n_qubits_each=n_each, methods=methods,\n                    phase_mode=self.phase_mode.get(), topology=topo,\n                    use_stateprep=True, do_measure=False\n                )\n                sv = simulate_statevector(qc)\n                key = f"multi[{','.join(labels)}|{topo}|{n_each}]"\n                self._set_active(key, sv, also_save=True)\n                # Multi summary\n                self.preview_text.delete("1.0", "end")\n                total_qubits = n_each * len(labels)\n                self.preview_text.insert("end",\n                    f"Prepared entangled multi-register Active:\n"\n                    f"  Labels: {', '.join(labels)}\n"\n                    f"  Topology: {topo}\n"\n                    f"  Qubits per register: {n_each}  |  Total qubits: {total_qubits}\n"\n                    f"  State length: {len(sv.data)}\n"\n                )\n\n        except Exception as e:\n            messagebox.showerror("Prepare/Run Error", str(e))\n\n    # ================== Tab 2: FFT Spectrum ==================\n    def _build_tab_fft(self):\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="FFT Spectrum")\n        panel = ttk.Frame(tab); panel.pack(fill="x", pady=6)\n        self.fft_use_active = tk.BooleanVar(value=True)\n        ttk.Checkbutton(panel, text="Use Active", variable=self.fft_use_active).pack(side="left", padx=6)\n        ttk.Button(panel, text="Compute FFT Spectrum", command=self.on_compute_fft).pack(side="left", padx=6)\n        self.fft_canvas_holder = ttk.Frame(tab); self.fft_canvas_holder.pack(fill="both", expand=True, padx=6, pady=6)\n\n    def on_compute_fft(self):\n        try:\n            mode = self.enc_mode.get()\n            n = int(self.n_qubits.get()); dim = 2 ** n\n\n            if self.fft_use_active.get():\n                if self.active_state is None:\n                    messagebox.showinfo("FFT", "No Active state. Prepare one first.")\n                    return\n                amps = self.active_state.data\n                label = self.active_state_label or "[active]"\n                subtitle = "Active"\n            else:\n                single = self._single_constant_required("FFT")\n                if not single:\n                    return\n                label, method = single\n                if mode not in {"EGF", "Terms"}:\n                    messagebox.showinfo("FFT", "Use EGF or Terms mode for Series-based FFT.")\n                    return\n                # Auto-switch for Terms-only labels when building from series\n                if _is_terms_only(label) and mode != "Terms":\n                    self.enc_mode.set("Terms")\n                    mode = "Terms"\n                    self._set_status(f"{label}: Terms-only — switched encoding to Terms.")\n                amps = get_series_amplitudes(\n                    label, dim, method=method, phase_mode=self.phase_mode.get(),\n                    normalize=True, amp_mode=("egf" if mode == "EGF" else "terms")\n                )\n                subtitle = f"{mode}"\n\n            power, freqs, mets = compute_fft_spectrum_from_amplitudes(\n                amps, remove_dc=True, window="hann", pad_len=int(self.pad_len.get())\n            )\n            for w in self.fft_canvas_holder.winfo_children(): w.destroy()\n            fig = plt.Figure(figsize=(9.5, 3.6)); ax = fig.add_subplot(111)\n            ax.plot(freqs, power, marker="o")\n            ax.set_title(f"{label} {subtitle} FFT (DC={mets['dc_frac']:.3f}, H={mets['entropy_bits']:.3f} bits)")\n            ax.set_xlabel("Frequency Index"); ax.set_ylabel("Power"); ax.grid(True)\n            canvas = FigureCanvasTkAgg(fig, master=self.fft_canvas_holder); canvas.draw()\n            canvas.get_tk_widget().pack(fill="both", expand=True)\n            self._set_status(f"FFT done. Peak@{int(np.argmax(power))}.")\n        except Exception as e:\n            messagebox.showerror("FFT Error", str(e))\n\n    # ================== Tab 3: QFT Spectrum ==================\n    def _build_tab_qft(self):\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="QFT Spectrum")\n        grid = ttk.Frame(tab); grid.pack(fill="x", pady=6)\n\n        self.qft_use_active = tk.BooleanVar(value=True)\n        ttk.Checkbutton(grid, text="Use Active", variable=self.qft_use_active).grid(row=0, column=0, padx=6, pady=4, sticky="w")\n\n        self.qft_do_measure = tk.BooleanVar(value=True)\n        ttk.Checkbutton(grid, text="Measure?", variable=self.qft_do_measure).grid(row=0, column=1, padx=6, pady=4, sticky="w")\n\n        ttk.Button(grid, text="Build QFT Circuit", command=self.on_build_qft_spectrum).grid(row=0, column=2, padx=6, pady=4, sticky="w")\n        ttk.Button(grid, text="Run (Backend/Sim)", command=self.on_run_qft_circuit).grid(row=0, column=3, padx=6, pady=4, sticky="w")\n        ttk.Button(grid, text="Simulate Statevector", command=self.on_simulate_qft_statevector).grid(row=0, column=4, padx=6, pady=4, sticky="w")\n\n        self.qft_counts_text = tk.Text(tab, height=18)\n        self.qft_counts_text.pack(fill="both", expand=True, padx=6, pady=6)\n\n        self.current_qft_circuit = None\n\n    def on_build_qft_spectrum(self):\n        try:\n            do_meas = bool(self.qft_do_measure.get())\n            if self.qft_use_active.get():\n                if self.active_state is None:\n                    self._set_status("No Active state. Prepare one first.")\n                    return\n                vec = self.active_state.data\n                vec = self._center_hann(vec=vec)\n                qc = index_qft_spectrum_circuit(vec, use_stateprep=True, do_measure=do_meas)\n                mets = self._spectrum_metrics(vec)\n                self.current_qft_circuit = qc\n                self.qft_counts_text.delete("1.0", "end")\n                self.qft_counts_text.insert("end", f"QFT (Active) built. len={len(vec)}, DC={mets['dc_frac']:.3f}, H={mets['entropy_bits']:.3f} bits\n")\n                self._set_status("QFT spectrum circuit (Active) ready.")\n            else:\n                single = self._single_constant_required("QFT")\n                if not single:\n                    return\n                label, method = single\n                n = int(self.n_qubits.get())\n                mode = self.enc_mode.get()\n                if mode not in {"EGF", "Terms"}:\n                    messagebox.showinfo("QFT", "Use EGF or Terms mode for Series-based QFT.")\n                    return\n                # Auto-switch for Terms-only label\n                if _is_terms_only(label) and mode != "Terms":\n                    self.enc_mode.set("Terms")\n                    mode = "Terms"\n                    self._set_status(f"{label}: Terms-only — switched encoding to Terms.")\n                qc, proc_vec, mets = qft_spectrum_from_series(\n                    label, n_qubits=n, method=method, phase_mode=self.phase_mode.get(),\n                    amp_mode=("egf" if mode == "EGF" else "terms"),\n                    preprocess=True, use_stateprep=True, do_measure=do_meas, pad_len=None\n                )\n                self.current_qft_circuit = qc\n                self.qft_counts_text.delete("1.0", "end")\n                self.qft_counts_text.insert("end", f"QFT (Series) built. len={mets['len']}, DC={mets['dc_frac']:.3f}, H={mets['entropy_bits']:.3f} bits\n")\n                self._set_status("QFT spectrum circuit (Series) ready.")\n        except Exception as e:\n            messagebox.showerror("QFT Build Error", str(e))\n\n    def on_run_qft_circuit(self):\n        try:\n            if not self.current_qft_circuit:\n                self._set_status("Build QFT spectrum circuit first.")\n                return\n            _, counts = run_circuit(self.current_qft_circuit, use_ibm=bool(self.use_ibm.get()), measure=True)\n            self.qft_counts_text.delete("1.0", "end")\n            if counts:\n                items = sorted(counts.items(), key=lambda kv: kv[1], reverse=True)\n                self.qft_counts_text.insert("end", f"Counts ({'IBM' if self.use_ibm.get() else 'Sim'}): top {min(32, len(items))}\n\n")\n                for k, v in items[:32]:\n                    self.qft_counts_text.insert("end", f"{k}: {v}\n")\n                self._set_status(f"Run complete. {len(counts)} bitstrings.")\n            else:\n                self.qft_counts_text.insert("end", "No counts available.\n")\n                self._set_status("Run complete (no counts).")\n        except Exception as e:\n            messagebox.showerror("QFT Run Error", str(e))\n\n    def on_simulate_qft_statevector(self):\n        try:\n            if not self.current_qft_circuit:\n                self._set_status("Build QFT spectrum circuit first.")\n                return\n            sv = simulate_statevector(self.current_qft_circuit)\n            self.qft_counts_text.insert("end", f"\nStatevector simulated:\nlen={len(sv)}\n")\n            self._set_status("Statevector simulated.")\n        except Exception:\n            self.qft_counts_text.insert("end", "\nCircuit has measurement — statevector not available.\n")\n            self._set_status("Statevector sim not available (measured circuit).")\n\n    # ================== Tab 4: Measurement ==================\n    def _build_tab_measure(self):\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="Measure")\n        ttk.Label(tab, text="Select saved state (or leave blank for Active):").pack(pady=5)\n        self.measure_combo = ttk.Combobox(tab, values=list(self.statevectors.keys())); self._register_combo(self.measure_combo); self.measure_combo.pack()\n        ttk.Button(tab, text="Simulate Measurements", command=self.on_measure_state).pack(pady=6)\n\n        # register helpers + deterministic controls\n        optrow = ttk.Frame(tab); optrow.pack(pady=(0,6))\n        self.show_reg_grid = tk.BooleanVar(value=True)\n        ttk.Checkbutton(optrow, text="Show register grid", variable=self.show_reg_grid).pack(side="left", padx=6)\n\n        self.meas_shots = tk.IntVar(value=1024)\n        ttk.Label(optrow, text="Shots").pack(side="left")\n        ttk.Spinbox(optrow, from_=1, to=131072, textvariable=self.meas_shots, width=7).pack(side="left", padx=4)\n\n        self.fix_seed = tk.BooleanVar(value=True)\n        ttk.Checkbutton(optrow, text="Fix RNG", variable=self.fix_seed).pack(side="left", padx=6)\n        self.meas_seed = tk.IntVar(value=12345)\n        ttk.Label(optrow, text="Seed").pack(side="left")\n        ttk.Spinbox(optrow, from_=0, to=2**31-1, textvariable=self.meas_seed, width=10).pack(side="left", padx=4)\n\n        self.exact_counts = tk.BooleanVar(value=False)\n        ttk.Checkbutton(optrow, text="Exact (shots×|amp|²)", variable=self.exact_counts).pack(side="left", padx=6)\n\n        ttk.Button(optrow, text="Show Register Marginals", command=self.on_show_marginals).pack(side="left", padx=12)\n\n        self.measure_canvas = ttk.Frame(tab); self.measure_canvas.pack(fill="both", expand=True)\n\n    def on_measure_state(self):\n        try:\n            lbl, sv = self._get_active_or_selected(self.measure_combo)\n            if sv is None:\n                messagebox.showinfo("Missing", "No active or selected state."); return\n\n            n = int(np.log2(len(sv.data)))\n            shots = int(self.meas_shots.get())\n\n            # Build counts\n            if self.exact_counts.get():\n                probs = np.abs(sv.data) ** 2\n                counts = {format(i, f'0{n}b'): int(round(shots * p)) for i, p in enumerate(probs)}\n            else:\n                qc = QuantumCircuit(n); qc.initialize(sv.data, range(n)); qc.measure_all()\n                if self.use_ibm.get():\n                    backend = get_backend(use_ibm=True)\n                else:\n                    backend = Aer.get_backend("qasm_simulator")\n                    if self.fix_seed.get():\n                        seed = int(self.meas_seed.get())\n                        try:\n                            backend.set_options(seed_simulator=seed, seed_transpiler=seed)\n                        except Exception:\n                            pass\n                counts = backend.run(qc, shots=shots).result().get_counts()\n\n            # sorted counts for plotting\n            items = sorted(((int(k, 2), v) for k, v in counts.items()), key=lambda t: t[0])\n            xs_counts = [x for x, _ in items]\n            ys_counts = [y for _, y in items]\n            labels = [format(x, f'0{n}b') for x in xs_counts]\n\n            probs = np.abs(sv.data) ** 2\n            xs_all = list(range(len(probs)))\n            ys_theory = [shots * p for p in probs]\n\n            # Try to parse multi-register layout\n            parsed = self._parse_multi_label(lbl)\n            regs, regq = ([], None)\n            if parsed:\n                regs, _topo, regq = parsed\n            else:\n                maybe = int(self.reg_qubits.get())\n                if n % max(1, maybe) == 0:\n                    regq = maybe\n                    R = n // regq\n                    regs = [f"R{i}" for i in range(R)]\n\n            for w in self.measure_canvas.winfo_children():\n                w.destroy()\n            fig, ax = plt.subplots(figsize=(10, 4))\n            ax.bar(xs_counts, ys_counts, label="Measured")\n            ax.plot(xs_all, ys_theory, marker="o", linestyle="-", label="Shots × |amp|²")\n\n            # thin tick labels if too dense\n            if len(xs_counts) > 64:\n                step = max(1, len(xs_counts) // 64)\n                take = list(range(0, len(xs_counts), step))\n                ax.set_xticks([xs_counts[i] for i in take])\n                ax.set_xticklabels([labels[i] for i in take], rotation=90, fontsize=8)\n            else:\n                ax.set_xticks(xs_counts)\n                ax.set_xticklabels(labels, rotation=90, fontsize=8)\n\n            title = f"Measurement Outcomes for {lbl}"\n            if regs and regq:\n                layout = " | ".join(f"{r}[{regq}]" for r in regs)\n                title += f"\nBit layout (MSB→LSB): {layout}"\n            ax.set_title(title)\n            ax.set_xlabel("Basis"); ax.set_ylabel("Counts")\n            if len(xs_counts) <= 256:\n                ax.legend(loc="upper right", fontsize=8)\n            fig.tight_layout()\n\n            # Register grid + Schmidt entropies\n            if self.show_reg_grid.get() and regs and regq:\n                R = len(regs)\n                N = 1 << n\n                major = 1 << (regq * (R - 1))     # leftmost register boundary\n                minor = (1 << (regq * (R - 2))) if R >= 2 else None\n                for x in range(0, N + 1, major):\n                    ax.axvline(x - 0.5, linewidth=1.2, alpha=0.25)\n                if minor:\n                    for x in range(0, N + 1, minor):\n                        ax.axvline(x - 0.5, linewidth=0.6, alpha=0.08, linestyle="--")\n\n                try:\n                    e_cuts = []\n                    for k in range(1, len(regs)):\n                        e_cuts.append(self._schmidt_entropy_bits(sv, cut=regq * k))\n                    if e_cuts:\n                        ax.text(0.02, 0.98,\n                                "Schmidt entropies (bits):  " +\n                                " | ".join([f"{'|'.join(regs[:k])} ‖ {'|'.join(regs[k:])}: {e:.3f}"\n                                            for k, e in enumerate(e_cuts, start=1)]),\n                                transform=ax.transAxes, va="top", ha="left", fontsize=9)\n                except Exception:\n                    pass\n\n            canvas = FigureCanvasTkAgg(fig, master=self.measure_canvas)\n            canvas.draw()\n            canvas.get_tk_widget().pack(fill="both", expand=True)\n        except Exception as e:\n            messagebox.showerror("Measurement Error", str(e))\n\n    def on_show_marginals(self):\n        try:\n            lbl, sv = self._get_active_or_selected(self.measure_combo)\n            if sv is None:\n                messagebox.showinfo("Marginals", "No active or selected state."); return\n\n            n = int(np.log2(len(sv.data)))\n            parsed = self._parse_multi_label(lbl)\n            if parsed:\n                regs, _topo, regq = parsed\n            else:\n                regq = int(self.reg_qubits.get())\n                if n % regq != 0:\n                    messagebox.showinfo("Marginals", "Can't infer register structure."); return\n                R = n // regq\n                regs = [f"R{i}" for i in range(R)]\n\n            R = len(regs)\n            probs = (np.abs(sv.data) ** 2).reshape(*([2 ** regq] * R))\n\n            for w in self.measure_canvas.winfo_children():\n                w.destroy()\n            fig, axes = plt.subplots(1, R, figsize=(4 * R, 3))\n            if R == 1:\n                axes = [axes]\n            for i in range(R):\n                axes_i = tuple(j for j in range(R) if j != i)\n                m = probs.sum(axis=axes_i)\n                xs = np.arange(2 ** regq)\n                axes[i].bar(xs, m)\n                axes[i].set_title(f"Marginal: {regs[i]}  ({regq} qubits)")\n                axes[i].set_xticks(xs)\n                axes[i].set_xticklabels([format(x, f'0{regq}b') for x in xs], fontsize=8, rotation=0)\n                axes[i].set_xlabel("Local basis"); axes[i].set_ylabel("Prob.")\n            fig.tight_layout()\n            canvas = FigureCanvasTkAgg(fig, master=self.measure_canvas); canvas.draw()\n            canvas.get_tk_widget().pack(fill="both", expand=True)\n        except Exception as e:\n            messagebox.showerror("Marginals Error", str(e))\n\n    # ================== Tab 5: Amplitudes (improved) ==================\n    def _build_tab_amplitudes(self):\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="Amplitudes")\n        row = ttk.Frame(tab); row.pack(fill="x", pady=4)\n        ttk.Label(row, text="Select saved state (or leave blank for Active):").pack(side="left")\n        self.amp_combo = ttk.Combobox(row, values=list(self.statevectors.keys())); self._register_combo(self.amp_combo); self.amp_combo.pack(side="left", padx=6)\n        ttk.Button(row, text="Set Active from Selected", command=self.on_set_active_from_amp).pack(side="left")\n        self.amp_log = tk.BooleanVar(value=False)\n        ttk.Checkbutton(row, text="Log scale", variable=self.amp_log).pack(side="left", padx=8)\n        ttk.Button(tab, text="Show |amp|^2", command=self.on_plot_amplitudes).pack(pady=6)\n        self.amp_canvas = ttk.Frame(tab); self.amp_canvas.pack(fill="both", expand=True)\n\n    def on_set_active_from_amp(self):\n        key = self.amp_combo.get()\n        if key in self.statevectors:\n            self._set_active(key, self.statevectors[key], also_save=False)\n\n    def on_plot_amplitudes(self):\n        try:\n            lbl, sv = self._get_active_or_selected(self.amp_combo)\n            if sv is None:\n                messagebox.showerror("Error", "No active or selected state."); return\n            probs = np.abs(sv.data) ** 2\n            n = len(probs)\n            xs = list(range(n))\n            if bool(self.amp_log.get()):\n                vals = np.log10(np.maximum(probs, 1e-12))\n                ylab = "log10 Probability"; suffix = " (log10)"\n            else:\n                vals = probs\n                ylab = "Probability"; suffix = ""\n            for w in self.amp_canvas.winfo_children(): w.destroy()\n            fig, ax = plt.subplots(figsize=(9, 4)); ax.bar(xs, vals)\n            ax.set_title(f"|amp|^2 for {lbl}{suffix}"); ax.set_xlabel("Basis Index"); ax.set_ylabel(ylab)\n            if n > 64:\n                step = max(1, n // 64)\n                ax.set_xticks(xs[::step]); ax.set_xticklabels(xs[::step], rotation=90, fontsize=8)\n            else:\n                ax.set_xticks(xs); ax.set_xticklabels(xs, rotation=90, fontsize=8)\n            fig.tight_layout()\n            canvas = FigureCanvasTkAgg(fig, master=self.amp_canvas); canvas.draw(); canvas.get_tk_widget().pack(fill="both", expand=True)\n        except Exception as e:\n            messagebox.showerror("Amplitude Plot Error", str(e))\n\n    # ================== Tab 6: Similarity ==================\n    def _build_tab_similarity(self):\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="Similarity")\n\n        opts = ttk.Frame(tab); opts.pack(fill="x", pady=6)\n        self.sim_include_active = tk.BooleanVar(value=True)\n        ttk.Checkbutton(opts, text="Include Active", variable=self.sim_include_active).pack(side="left", padx=6)\n        self.sim_split_multi = tk.BooleanVar(value=True)\n        ttk.Checkbutton(opts, text="Split multi into registers", variable=self.sim_split_multi).pack(side="left", padx=6)\n        ttk.Button(opts, text="Compute Cosine Similarity", command=self.on_similarity).pack(side="left", padx=8)\n\n        self.sim_text = tk.Text(tab, height=18); self.sim_text.pack(fill="both", expand=True, padx=6, pady=6)\n\n    def _collect_vectors_for_stats(self, split_multi: bool, include_active: bool):\n        """\n        Build comparable feature matrix for stats.\n        - Whole states → probability vector |amp|^2 (length N).\n        - Multi states with split → per-register marginals (length 2**RegQ).\n        Returns (labels, X) where X is zero-padded to a common width.\n        """\n        labels: List[str] = []\n        vecs: List[np.ndarray] = []\n\n        def add_state(name: str, sv: Statevector):\n            parsed = self._parse_multi_label(name)\n            if split_multi and parsed:\n                regs, _topo, regq = parsed\n                for rname, marg in self._register_marginals(sv, regq, regs):\n                    labels.append(f"{name}:{rname}")\n                    vecs.append(np.asarray(marg, dtype=float))\n            else:\n                p = np.abs(sv.data) ** 2\n                labels.append(name)\n                vecs.append(np.asarray(p, dtype=float))\n\n        for k, sv in self.statevectors.items():\n            add_state(k, sv)\n\n        if include_active and self.active_state is not None and (self.active_state_label not in self.statevectors):\n            add_state(self.active_state_label or "[active]", self.active_state)\n\n        X = self._pad_stack(vecs)\n        return labels, X\n\n    def on_similarity(self):\n        try:\n            from sklearn.metrics.pairwise import cosine_similarity\n            labels, X = self._collect_vectors_for_stats(self.sim_split_multi.get(), self.sim_include_active.get())\n            if X.shape[0] < 2:\n                self.sim_text.delete("1.0", "end"); self.sim_text.insert("end", "Need at least 2 states (or registers).\n"); return\n            sim = cosine_similarity(X)\n            self.sim_text.delete("1.0", "end")\n            header = "         " + " ".join(f"{k[:14]:>14}" for k in labels) + "\n"; self.sim_text.insert("end", header)\n            for i, row in enumerate(sim):\n                self.sim_text.insert("end", f"{labels[i][:14]:>14}: " + " ".join(f"{v:>14.3f}" for v in row) + "\n")\n        except Exception as e:\n            messagebox.showerror("Similarity Error", str(e))\n\n    # ================== Tab 7: Clustering ==================\n    def _build_tab_clustering(self):\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="Clustering")\n\n        opts = ttk.Frame(tab); opts.pack(fill="x", pady=6)\n        self.pca_include_active = tk.BooleanVar(value=True)\n        ttk.Checkbutton(opts, text="Include Active", variable=self.pca_include_active).pack(side="left", padx=6)\n        self.pca_split_multi = tk.BooleanVar(value=True)\n        ttk.Checkbutton(opts, text="Split multi into registers", variable=self.pca_split_multi).pack(side="left", padx=6)\n        ttk.Button(opts, text="Run PCA", command=self.on_clustering).pack(side="left", padx=8)\n\n        self.cluster_canvas = ttk.Frame(tab); self.cluster_canvas.pack(fill="both", expand=True)\n        self.cluster_listbox = tk.Listbox(tab, selectmode=MULTIPLE, height=5, exportselection=False)\n        self.cluster_listbox.pack(fill="x", padx=10, pady=6)\n\n    def on_clustering(self):\n        try:\n            from sklearn.decomposition import PCA\n            labels, X = self._collect_vectors_for_stats(self.pca_split_multi.get(), self.pca_include_active.get())\n            if X.shape[0] < 2:\n                messagebox.showinfo("Clustering", "Need at least 2 items."); return\n            proj = PCA(n_components=2).fit_transform(X)\n            for w in self.cluster_canvas.winfo_children(): w.destroy()\n            fig, ax = plt.subplots(figsize=(7, 5))\n            for i, lbl in enumerate(labels):\n                ax.scatter(proj[i, 0], proj[i, 1])\n                ax.text(proj[i, 0], proj[i, 1], lbl, fontsize=8, ha="left", va="bottom")\n            ax.set_title("PCA Projection"); ax.grid(True)\n            canvas = FigureCanvasTkAgg(fig, master=self.cluster_canvas); canvas.draw(); canvas.get_tk_widget().pack(fill="both", expand=True)\n        except Exception as e:\n            messagebox.showerror("Clustering Error", str(e))\n\n    # ================== Tab 8: Tomography ==================\n    def _build_tab_tomography(self):\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="Tomography")\n        if not TOMO_OK:\n            ttk.Label(tab, text="qiskit-experiments not available.").pack(pady=8); return\n        ttk.Label(tab, text="Select saved state (or leave blank for Active):").pack(pady=5)\n        self.tomo_combo = ttk.Combobox(tab, values=list(self.statevectors.keys())); self._register_combo(self.tomo_combo); self.tomo_combo.pack()\n        ttk.Button(tab, text="Run Tomography", command=self.on_run_tomography).pack(pady=6)\n        self.tomo_canvas = ttk.Frame(tab); self.tomo_canvas.pack(fill="both", expand=True)\n\n    def on_run_tomography(self):\n        try:\n            if not TOMO_OK: return\n            lbl, sv = self._get_active_or_selected(self.tomo_combo)\n            if sv is None:\n                messagebox.showinfo("Tomography", "No active or selected state."); return\n\n            n = int(np.log2(len(sv.data)))\n            qc = QuantumCircuit(n); qc.initialize(sv.data, range(n))\n\n            # Prefer AerSimulator if available\n            if self.use_ibm.get():\n                backend = get_backend(use_ibm=True)\n            else:\n                backend = AerSimulator() if AerSimulator is not None else Aer.get_backend("qasm_simulator")\n\n            tomo = StateTomography(qc)\n            try:\n                expdata = tomo.run(backend, shots=2048)\n                expdata.block_for_results()\n                rho_fit = None\n                for ar in expdata.analysis_results():\n                    try:\n                        nm = getattr(ar, "name", "")\n                        if nm in ("state", "state_fit", "DensityMatrix", "rho"):\n                            rho_fit = ar.value\n                            break\n                    except Exception:\n                        pass\n                if rho_fit is None:\n                    ars = expdata.analysis_results()\n                    if ars:\n                        rho_fit = ars[0].value\n                if rho_fit is None:\n                    raise RuntimeError("Tomography produced no state.")\n                fid = float(state_fidelity(DensityMatrix(sv), rho_fit))\n                warn = None\n            except Exception as e:\n                # Graceful fallback when Aer can't handle certain instructions\n                fid = 1.0\n                warn = f"Tomography fallback used: {e}"\n\n            for w in self.tomo_canvas.winfo_children(): w.destroy()\n            fig, ax = plt.subplots(figsize=(6, 4))\n            title = f"Fidelity: {fid:.6f}  ({lbl})"\n            if warn:\n                title += "\n(Fallback: ideal self-fidelity)"\n            ax.set_title(title)\n            ax.text(0.5, 0.5, f"{fid:.6f}", fontsize=20, ha="center", va="center")\n            fig.tight_layout()\n            canvas = FigureCanvasTkAgg(fig, master=self.tomo_canvas); canvas.draw(); canvas.get_tk_widget().pack(fill="both", expand=True)\n        except Exception as e:\n            messagebox.showerror("Tomography Error", str(e))\n\n    # ================== Tab 9: Entanglement ==================\n    def _build_tab_entanglement(self):\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="Entanglement")\n\n        self.ent_mode = tk.StringVar(value="series")\n        ttk.Radiobutton(tab, text="Simple (2-qubit fractional)", variable=self.ent_mode, value="simple").grid(row=0, column=0, sticky="w", padx=4)\n        ttk.Radiobutton(tab, text="Series registers", variable=self.ent_mode, value="series").grid(row=0, column=1, sticky="w", padx=4)\n        ttk.Radiobutton(tab, text="Multi (CSV)", variable=self.ent_mode, value="multi").grid(row=0, column=2, sticky="w", padx=4)\n\n        self.ent1 = tk.StringVar(value="π"); self.ent2 = tk.StringVar(value="ζ(3)")\n        ttk.Label(tab, text="Const 1:").grid(row=1, column=0, sticky="e"); ttk.Combobox(tab, textvariable=self.ent1, values=SUGGESTED_LABELS, state="normal", width=24).grid(row=1, column=1, sticky="w")\n        ttk.Label(tab, text="Const 2:").grid(row=2, column=0, sticky="e"); ttk.Combobox(tab, textvariable=self.ent2, values=SUGGESTED_LABELS, state="normal", width=24).grid(row=2, column=1, sticky="w")\n\n        self.series_qubits_each = tk.IntVar(value=3)\n        self.series_pattern = tk.StringVar(value="cx_all")\n        ttk.Label(tab, text="Series qubits each:").grid(row=3, column=0, sticky="e"); ttk.Spinbox(tab, from_=1, to=8, textvariable=self.series_qubits_each, width=5).grid(row=3, column=1, sticky="w")\n        ttk.Label(tab, text="Pattern:").grid(row=3, column=2, sticky="e"); ttk.Combobox(tab, textvariable=self.series_pattern, values=["cx_all","bell_on_0"], state="readonly", width=10).grid(row=3, column=3, sticky="w")\n\n        ttk.Label(tab, text="Multi CSV (e.g. π,ζ(3),e)").grid(row=4, column=0, sticky="e")\n        self.multi_csv = tk.Entry(tab, width=40); self.multi_csv.insert(0, "π,ζ(3),e"); self.multi_csv.grid(row=4, column=1, columnspan=2, sticky="w")\n\n        self.multi_topology_tab = tk.StringVar(value="chain")\n        ttk.Label(tab, text="Topology:").grid(row=4, column=3, sticky="e"); ttk.Combobox(tab, textvariable=self.multi_topology_tab, values=["chain","star","all_to_all"], state="readonly", width=10).grid(row=4, column=4, sticky="w")\n\n        ttk.Button(tab, text="Build & Analyze", command=self.on_ent_analyze).grid(row=5, column=0, columnspan=5, pady=6)\n        self.ent_canvas = ttk.Frame(tab); self.ent_canvas.grid(row=6, column=0, columnspan=5, sticky="nsew")\n\n    def on_ent_analyze(self):\n        try:\n            for w in self.ent_canvas.winfo_children(): w.destroy()\n            mode = self.ent_mode.get()\n\n            if mode == "simple":\n                c1 = compute_series(self.ent1.get(), 100)\n                c2 = compute_series(self.ent2.get(), 100)\n                qc = encode_entangled_constants(c1, c2)\n                sv = simulate_statevector(qc); cut = 1\n\n            elif mode == "series":\n                n_each = int(self.series_qubits_each.get())\n                c1, c2 = self.ent1.get(), self.ent2.get()\n                m1 = self.pi_method.get() if _supports_method(c1) else None\n                m2 = self.pi_method.get() if _supports_method(c2) else None\n                qc = entangle_series_registers(\n                    c1, c2, n_qubits_each=n_each, method1=m1, method2=m2,\n                    phase_mode1=self.phase_mode.get(), phase_mode2=self.phase_mode.get(),\n                    pattern=self.series_pattern.get(), use_stateprep=True, do_measure=False\n                )\n                sv = simulate_statevector(qc); cut = n_each\n\n            else:\n                labels = [s.strip() for s in self.multi_csv.get().split(",") if s.strip()]\n                if len(labels) < 2:\n                    messagebox.showinfo("Multi", "Provide at least 2 labels."); return\n                n_each = int(self.series_qubits_each.get())\n                topo = self.multi_topology_tab.get()\n                qc = entangle_series_multi(\n                    labels, n_qubits_each=n_each, methods=None,\n                    phase_mode=self.phase_mode.get(), topology=topo,\n                    use_stateprep=True, do_measure=False\n                )\n                sv = simulate_statevector(qc); cut = n_each * (len(labels)//2)\n\n            rhoA, rhoB, rhoAB = analyze_tensor_structure(sv)\n            S = perform_schmidt_decomposition(sv, cut=cut)\n            fig, axs = plt.subplots(1, 2, figsize=(10, 4))\n            probs = np.abs(sv.data) ** 2\n            axs[0].bar(range(len(probs)), probs); axs[0].set_title("Entangled State Spectrum")\n            axs[1].imshow(np.outer(S, S), cmap="magma"); axs[1].set_title("Schmidt (outer product)")\n            fig.tight_layout()\n            canvas = FigureCanvasTkAgg(fig, master=self.ent_canvas); canvas.draw(); canvas.get_tk_widget().pack(fill="both", expand=True)\n            self._set_active(f"ent[{mode}]", sv, also_save=False)\n        except Exception as e:\n            messagebox.showerror("Entanglement Error", str(e))\n\n    # ================== Tab 10: Gates ==================\n    def _build_tab_gates(self):\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="Gates")\n\n        row = ttk.Frame(tab); row.pack(fill="x", pady=6)\n        self.gate_decompose = tk.BooleanVar(value=False)\n        ttk.Checkbutton(row, text="Decompose initialize", variable=self.gate_decompose).pack(side="left", padx=6)\n\n        self.gate_hide_init = tk.BooleanVar(value=True)\n        ttk.Checkbutton(row, text="Hide initialize box", variable=self.gate_hide_init).pack(side="left", padx=6)\n\n        self.gate_barrier_split = tk.BooleanVar(value=True)\n        ttk.Checkbutton(row, text="Barrier after prep", variable=self.gate_barrier_split).pack(side="left", padx=6)\n\n        self.gate_reverse = tk.BooleanVar(value=False)\n        ttk.Checkbutton(row, text="Reverse bits", variable=self.gate_reverse).pack(side="left", padx=6)\n\n        ttk.Label(row, text="Wrap width (fold)").pack(side="left")\n        self.gate_fold = tk.IntVar(value=120)\n        ttk.Spinbox(row, from_=40, to=240, textvariable=self.gate_fold, width=6).pack(side="left", padx=4)\n\n        ttk.Label(row, text="Figure width").pack(side="left")\n        self.gate_figw = tk.DoubleVar(value=10.0)\n        ttk.Spinbox(row, from_=6.0, to=18.0, increment=0.5, textvariable=self.gate_figw, width=6).pack(side="left", padx=4)\n\n        btns = ttk.Frame(tab); btns.pack(fill="x", pady=(0,6))\n        ttk.Button(btns, text="Draw Current QFT Circuit (if any)", command=self.on_draw_qft).pack(side="left", padx=6)\n        ttk.Button(btns, text="Draw Prep for Active/Last Saved", command=self.on_draw_prep_for_last).pack(side="left", padx=6)\n        ttk.Button(btns, text="Draw (ASCII / Text)", command=self.on_draw_text).pack(side="left", padx=6)\n        ttk.Button(btns, text="Show Summary", command=self.on_draw_summary).pack(side="left", padx=6)\n\n        self.gate_canvas = ttk.Frame(tab); self.gate_canvas.pack(fill="both", expand=True)\n        self.gate_text = tk.Text(tab, height=12, font=("Courier", 10))\n        self.gate_text.pack(fill="both", expand=False, padx=6, pady=(6,8))\n\n    def _make_drawable_circuit(self, qc: QuantumCircuit) -> Tuple[QuantumCircuit, bool]:\n        """Return a circuit ready for drawing and whether we saw initialize."""\n        draw_circ = QuantumCircuit(*qc.qregs, *qc.cregs)\n        saw_init = False\n\n        for inst, qargs, cargs in qc.data:\n            name = getattr(inst, "name", "")\n            if name in ("initialize", "state_preparation", "initialize_"):\n                saw_init = True\n                if self.gate_decompose.get():\n                    # keep the real initialize so decompose() can expand it\n                    draw_circ.append(inst, qargs, cargs)\n                else:\n                    if self.gate_hide_init.get():\n                        # replace with a compact placeholder\n                        dummy = Instruction(name="Init |ψ⟩", num_qubits=len(qargs), num_clbits=len(cargs), params=[])\n                        draw_circ.append(dummy, qargs, cargs)\n                    else:\n                        # show as-is (may be verbose)\n                        draw_circ.append(inst, qargs, cargs)\n                if self.gate_barrier_split.get() and draw_circ.num_qubits:\n                    draw_circ.barrier(*draw_circ.qubits)\n            else:\n                draw_circ.append(inst, qargs, cargs)\n\n        return draw_circ, saw_init\n\n    def _draw_circuit_on_canvas(self, qc: QuantumCircuit):\n        for w in self.gate_canvas.winfo_children(): w.destroy()\n        try:\n            draw_circ, saw_init = self._make_drawable_circuit(qc)\n            if self.gate_decompose.get():\n                draw_circ = draw_circ.decompose(reps=4)\n            fig = draw_circ.draw(\n                output="mpl",\n                fold=int(self.gate_fold.get()),\n                reverse_bits=bool(self.gate_reverse.get()),\n                idle_wires=False,\n                style={"figwidth": float(self.gate_figw.get())}\n            )\n            canvas = FigureCanvasTkAgg(fig, master=self.gate_canvas)\n            canvas.draw()\n            canvas.get_tk_widget().pack(fill="both", expand=True)\n\n            # Brief hint in text area so the tab always conveys something.\n            self.gate_text.delete("1.0", "end")\n            hint = "initialize hidden" if (saw_init and self.gate_hide_init.get() and not self.gate_decompose.get()) else \\n                   ("initialize decomposed" if (saw_init and self.gate_decompose.get()) else "no initialize found")\n            self.gate_text.insert("end", f"[Gates] Drew circuit ({hint}). Toggle options above to change view.\n")\n        except Exception as e:\n            messagebox.showerror("Gate Draw Error", str(e))\n\n    def on_draw_qft(self):\n        if not getattr(self, "current_qft_circuit", None):\n            self._set_status("No QFT circuit yet."); return\n        self._draw_circuit_on_canvas(self.current_qft_circuit)\n\n    def on_draw_prep_for_last(self):\n        try:\n            if self.active_state is not None:\n                sv = self.active_state; label = self.active_state_label or "[active]"\n            else:\n                keys = list(self.statevectors.keys())\n                if not keys: self._set_status("No states available."); return\n                label = keys[-1]; sv = self.statevectors[label]\n            n = int(np.log2(len(sv.data)))\n            qc = QuantumCircuit(n); qc.initialize(sv.data, range(n))\n            self._draw_circuit_on_canvas(qc)\n            self._set_status(f"Drew prep circuit for {label}")\n        except Exception as e:\n            messagebox.showerror("Gate Draw Error", str(e))\n\n    def on_draw_text(self):\n        """ASCII/text drawer—always readable, never ellipses."""\n        try:\n            qc = None\n            if getattr(self, "current_qft_circuit", None):\n                qc = self.current_qft_circuit\n            elif self.active_state is not None:\n                n = int(np.log2(len(self.active_state.data)))\n                qc = QuantumCircuit(n); qc.initialize(self.active_state.data, range(n))\n            else:\n                messagebox.showinfo("Text Draw", "Nothing to draw yet."); return\n\n            draw_circ, _ = self._make_drawable_circuit(qc)\n            if self.gate_decompose.get():\n                draw_circ = draw_circ.decompose(reps=4)\n            txt = str(draw_circ.draw(output="text", fold=int(self.gate_fold.get())))\n            self.gate_text.delete("1.0", "end")\n            self.gate_text.insert("end", txt + "\n")\n        except Exception as e:\n            messagebox.showerror("Text Draw Error", str(e))\n\n    def on_draw_summary(self):\n        """Quick numeric summary of the circuit so the tab always conveys info."""\n        try:\n            qc = None\n            if getattr(self, "current_qft_circuit", None):\n                qc = self.current_qft_circuit\n            elif self.active_state is not None:\n                n = int(np.log2(len(self.active_state.data)))\n                qc = QuantumCircuit(n); qc.initialize(self.active_state.data, range(n))\n            else:\n                messagebox.showinfo("Summary", "Nothing to summarize yet."); return\n\n        # Avoid AttributeError variations across Qiskit versions:\n            try:\n                counts = qc.count_ops()\n            except Exception:\n                counts = {}\n            try:\n                depth = qc.depth()\n            except Exception:\n                depth = -1\n            try:\n                size = qc.size()\n            except Exception:\n                size = len(qc.data)\n\n            summary = [\n                f"Qubits: {qc.num_qubits}   Clbits: {qc.num_clbits}",\n                f"Depth: {depth}   Size (ops): {size}",\n                "Ops:",\n            ] + [f"  {k}: {v}" for k, v in sorted(counts.items(), key=lambda kv: (-kv[1], kv[0]))]\n\n            self.gate_text.delete("1.0", "end")\n            self.gate_text.insert("end", "\n".join(summary) + "\n")\n        except Exception as e:\n            messagebox.showerror("Summary Error", str(e))\n\n    # ================== Tab 11: State I/O ==================\n    def _build_tab_state_io(self):\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="State I/O")\n        ttk.Button(tab, text="Save Active", command=self.on_save_active).pack(pady=6)\n        ttk.Button(tab, text="Load State (becomes Active)", command=self.on_load_state).pack(pady=6)\n\n    def on_save_active(self):\n        """Save the Active state using a native Save dialog (macOS-safe)."""\n        try:\n            if self.active_state is None:\n                messagebox.showinfo("Save", "No active state.")\n                return\n            label = self.active_state_label or "active_state"\n            saved_path = save_statevector_dialog(self, self.active_state, label)\n            if saved_path:\n                self.statevectors[label] = self.active_state\n                self._refresh_all_combos()\n                self._set_status(f"Saved: {saved_path}")\n        except Exception as e:\n            messagebox.showerror("Save Error", str(e))\n\n    def on_load_state(self):\n        """Load a state from disk via native Open dialog (macOS-safe)."""\n        try:\n            res = load_statevector_dialog(self)\n            if not res:\n                return  # user cancelled\n            label, sv = res\n            self._set_active(label, sv, also_save=True)\n        except Exception as e:\n            messagebox.showerror("Load Error", str(e))\n\n    # ================== Tab 12: Basis States ==================\n    def _build_tab_basis(self):\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="Basis States")\n        row = ttk.Frame(tab); row.pack(fill="x", pady=4)\n        ttk.Label(row, text="Select saved state (or leave blank for Active):").pack(side="left")\n        self.basis_combo = ttk.Combobox(row, values=list(self.statevectors.keys())); self._register_combo(self.basis_combo); self.basis_combo.pack(side="left", padx=6)\n        ttk.Button(row, text="Set Active from Selected", command=self.on_set_active_from_basis).pack(side="left")\n        ttk.Button(tab, text="Show Basis Amplitudes", command=self.on_show_basis).pack(pady=6)\n        self.basis_text = tk.Text(tab, height=22, font=("Courier", 10)); self.basis_text.pack(fill="both", expand=True, padx=6, pady=6)\n\n    def on_set_active_from_basis(self):\n        key = self.basis_combo.get()\n        if key in self.statevectors:\n            self._set_active(key, self.statevectors[key], also_save=False)\n\n    def on_show_basis(self):\n        try:\n            lbl, sv = self._get_active_or_selected(self.basis_combo)\n            if sv is None:\n                messagebox.showinfo("Basis", "No active or selected state."); return\n            n = int(np.log2(len(sv.data)))\n            self.basis_text.delete("1.0", "end")\n            for i, a in enumerate(sv.data):\n                self.basis_text.insert("end", f"|{i:0{n}b}⟩  →  {a.real:+.6f}{'+' if a.imag>=0 else ''}{a.imag:.6f}j\n")\n        except Exception as e:\n            messagebox.showerror("Basis Error", str(e))\n\n    # ================== Tab 13: Chunks (Hierarchical) — NEW ==================\n    def _build_tab_chunks(self):\n        self._build_tab_reference()\n        self._build_tab_export()\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="Chunks (Hierarchical)")\n\n        controls = ttk.Frame(tab); controls.pack(fill="x", pady=6)\n        self.chunks_use_active = tk.BooleanVar(value=True)\n        ttk.Checkbutton(controls, text="Use Active", variable=self.chunks_use_active).pack(side="left", padx=6)\n\n        ttk.Label(controls, text="Chunk qubits k").pack(side="left")\n        self.chunk_k = tk.IntVar(value=2)\n        ttk.Spinbox(controls, from_=1, to=10, textvariable=self.chunk_k, width=5).pack(side="left", padx=4)\n\n        ttk.Label(controls, text="Merge rule").pack(side="left", padx=(8,0))\n        self.merge_rule = tk.StringVar(value="norm-weighted")\n        ttk.Combobox(controls, textvariable=self.merge_rule,\n                     values=["sum", "mean", "norm-weighted"], state="readonly", width=14).pack(side="left", padx=4)\n\n        self.chunks_plot = tk.BooleanVar(value=True)\n        ttk.Checkbutton(controls, text="Plot first pair (level 0)", variable=self.chunks_plot).pack(side="left", padx=8)\n\n        ttk.Button(controls, text="Run Chunk Merge", command=self.on_run_chunks).pack(side="left", padx=12)\n\n        self.chunks_canvas = ttk.Frame(tab); self.chunks_canvas.pack(fill="both", expand=True, padx=6, pady=6)\n        self.chunks_text = tk.Text(tab, height=14); self.chunks_text.pack(fill="both", expand=False, padx=6, pady=(0,8))\n\n    @staticmethod\n    def _cos_sim(u: np.ndarray, v: np.ndarray, eps: float = 1e-15) -> float:\n        u = np.asarray(u, dtype=np.complex128).reshape(-1)\n        v = np.asarray(v, dtype=np.complex128).reshape(-1)\n        num = np.vdot(u, v)  # conjugate dot\n        den = np.linalg.norm(u) * np.linalg.norm(v) + eps\n        return float(np.abs(num) / den)\n\n    def on_run_chunks(self):\n        try:\n            # 1) Get amplitude vector\n            if self.chunks_use_active.get():\n                if self.active_state is None:\n                    messagebox.showinfo("Chunks", "No Active state — prepare one or uncheck 'Use Active'.")\n                    return\n                vec = np.asarray(self.active_state.data, dtype=np.complex128)\n                label = self.active_state_label or "[active]"\n            else:\n                single = self._single_constant_required("Chunks")\n                if not single:\n                    return\n                label, method = single\n                n = int(self.n_qubits.get()); dim = 2 ** n\n                mode = self.enc_mode.get()\n                if mode not in {"EGF", "Terms"}:\n                    messagebox.showinfo("Chunks", "Use EGF or Terms to build a series amplitude vector.")\n                    return\n                if _is_terms_only(label) and mode != "Terms":\n                    self.enc_mode.set("Terms")\n                    mode = "Terms"\n                    self._set_status(f"{label}: Terms-only — switched encoding to Terms.")\n                vec = np.asarray(\n                    get_series_amplitudes(label, dim, method=method, phase_mode=self.phase_mode.get(),\n                                          normalize=True, amp_mode=("egf" if mode == "EGF" else "terms")),\n                    dtype=np.complex128\n                )\n\n            N = vec.size\n            k = int(self.chunk_k.get())\n            M = 1 << k  # chunk size\n            if M <= 0 or N % M != 0:\n                messagebox.showinfo("Chunks", f"Chunk size 2^{k} must divide state length N={N}."); return\n\n            # 2) Build initial chunks\n            L0 = N // M\n            chunks = [vec[i*M:(i+1)*M].copy() for i in range(L0)]\n\n            # 3) Iteratively pair-merge\n            rule = self.merge_rule.get()\n            levels = []\n            level_id = 0\n            eps = 1e-15\n\n            while len(chunks) > 1:\n                pairs = []\n                stats = []\n                next_chunks = []\n                for i in range(0, len(chunks), 2):\n                    if i + 1 >= len(chunks):\n                        # odd tail — carry forward\n                        next_chunks.append(chunks[i])\n                        continue\n                    c0, c1 = chunks[i], chunks[i+1]\n                    # stats\n                    n0 = float(np.linalg.norm(c0))\n                    n1 = float(np.linalg.norm(c1))\n                    p0 = n0**2; p1 = n1**2\n                    frac0 = p0 / max(p0 + p1, eps)\n                    cos01 = self._cos_sim(c0, c1, eps=eps)\n                    stats.append((i//2, frac0, 1.0 - frac0, cos01))\n\n                    # merge\n                    if rule == "sum":\n                        v = c0 + c1\n                    elif rule == "mean":\n                        v = 0.5 * (c0 + c1)\n                    else:  # norm-weighted\n                        w0 = n0; w1 = n1\n                        denom = max(w0 + w1, eps)\n                        v = (w0 * c0 + w1 * c1) / denom\n\n                    # normalize merged chunk to unit norm to keep comparisons robust\n                    nv = np.linalg.norm(v)\n                    if nv > 0:\n                        v = v / nv\n                    next_chunks.append(v)\n                    pairs.append((c0, c1, v))\n\n                levels.append({"level": level_id, "pairs": pairs, "stats": stats})\n                chunks = next_chunks\n                level_id += 1\n                if len(chunks) == 1:\n                    break\n\n            # 4) Report\n            self.chunks_text.delete("1.0", "end")\n            self.chunks_text.insert("end", f"Chunks Hierarchy for {label}\n")\n            self.chunks_text.insert("end", f"N={N}, chunk_size=2^{k}={M}, initial_chunks={L0}, merge_rule={rule}\n\n")\n            for L in levels:\n                stats = L["stats"]\n                if not stats:\n                    continue\n                idxs = [s[0] for s in stats]\n                frac0s = [s[1] for s in stats]\n                frac1s = [s[2] for s in stats]\n                coss = [s[3] for s in stats]\n                self.chunks_text.insert("end",\n                    f"Level {L['level']}: pairs={len(stats)} | "\n                    f"mean frac(left)={np.mean(frac0s):.3f} ± {np.std(frac0s):.3f} | "\n                    f"mean cos={np.mean(coss):.3f} (min={np.min(coss):.3f}, max={np.max(coss):.3f})\n"\n                )\n            self.chunks_text.insert("end", "\nDone.\n")\n\n            # 5) Optional plot: first pair at level 0\n            for w in self.chunks_canvas.winfo_children(): w.destroy()\n            if levels and bool(self.chunks_plot.get()):\n                first = levels[0]["pairs"]\n                if first:\n                    c0, c1, v = first[0]\n                    xs = np.arange(M)\n                    fig, ax = plt.subplots(figsize=(10, 4))\n                    ax.bar(xs - 0.25, np.abs(c0)**2, width=0.25, label="Chunk 0 |amp|^2")\n                    ax.bar(xs,        np.abs(c1)**2, width=0.25, label="Chunk 1 |amp|^2")\n                    ax.plot(xs,       np.abs(v)**2,  marker="o", linestyle="-", label="Merged |amp|^2")\n                    ax.set_title(f"Level 0, Pair 0 — chunk size {M}")\n                    ax.set_xlabel("Local basis index within chunk")\n                    ax.set_ylabel("Probability")\n                    if M > 64:\n                        step = max(1, M // 64)\n                        ax.set_xticks(xs[::step])\n                        ax.set_xticklabels(xs[::step], rotation=90, fontsize=8)\n                    else:\n                        ax.set_xticks(xs)\n                        ax.set_xticklabels(xs, rotation=90, fontsize=8)\n                    ax.legend(fontsize=8)\n                    fig.tight_layout()\n                    canvas = FigureCanvasTkAgg(fig, master=self.chunks_canvas)\n                    canvas.draw()\n                    canvas.get_tk_widget().pack(fill="both", expand=True)\n\n        except Exception as e:\n            messagebox.showerror("Chunks Error", str(e))\n\n    # ---------- helpers for QFT metrics ----------\n    def _center_hann(self, vec: np.ndarray) -> np.ndarray:\n        x = vec.astype(np.complex128); m = np.mean(x); x = x - m\n        if x.size > 1: x = x * np.hanning(x.size)\n        return x\n\n    def _spectrum_metrics(self, vec: np.ndarray) -> dict:\n        X = np.fft.fft(vec); P = np.abs(X) ** 2; S = P.sum() or 1.0\n        dc = float(P[0] / S); p = P / S; p = p[p > 0]\n        H = float(-np.sum(p * np.log2(p)))\n        return {"dc_frac": dc, "entropy_bits": H}\n\n\n    def _build_tab_reference(self):\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="Reference")\n        txt = tk.Text(tab, height=28, wrap="word"); txt.pack(fill="both", expand=True, padx=6, pady=6)\n        content = (\n            "QTE Reference\n"\n            "————————————\n\n"\n            "J0(x) series:\n"\n            "  J0(x) = sum_{k≥0} (-1)^k (x/2)^{2k} / (k!)^2\n\n"\n            "Zeta, polylog identities:\n"\n            "  ζ(2) = π^2 / 6\n"\n            "  Li₂(1/2) = π^2/12 − (ln 2)^2/2\n"\n            "  Li₃(1/2) = (7/8)ζ(3) − (π^2/12)ln 2 + (ln 2)^3/6\n\n"\n            "Modes used here:\n"\n            "  Terms: direct Maclaurin coefficients as amplitudes (with chosen phase mode).\n"\n            "  EGF:   exponential generating function sampling.\n\n"\n            "Spectra:\n"\n            "  FFT: classical FFT of amplitudes (windowed, DC-removed).\n"\n            "  QFT: apply QFT to index register; measure or simulate.\n"\n        )\n        try:\n            txt.insert("end", content)\n        except Exception:\n            pass\n\n    def _build_tab_export(self):\n        tab = ttk.Frame(self.nb); self.nb.add(tab, text="Paper Export")\n        ttk.Button(tab, text="Generate plots for Active", command=self._export_plots_active).pack(pady=8)\n        self.export_text = tk.Text(tab, height=18); self.export_text.pack(fill="both", expand=True, padx=6, pady=6)\n\n    def _export_plots_active(self):\n        try:\n            import os, time\n            if self.active_state is None:\n                messagebox.showinfo("Export", "No Active state."); return\n            label = self.active_state_label or "active"\n            vec = self.active_state.data\n            probs = (np.abs(vec)**2)\n            outdir = "paper_outputs"; os.makedirs(outdir, exist_ok=True)\n            ts = time.strftime("%Y%m%d-%H%M%S")\n            safe_label = str(label).replace("/", "_").replace(" ", "_")\n            f1 = os.path.join(outdir, f"{safe_label}_amps_{ts}.png")\n            fig, ax = plt.subplots(figsize=(9,3.2)); ax.bar(range(len(probs)), probs)\n            ax.set_title(f"{label} |amp|^2"); ax.set_xlabel("index"); ax.set_ylabel("prob"); fig.tight_layout(); fig.savefig(f1); plt.close(fig)\n            power, freqs, mets = compute_fft_spectrum_from_amplitudes(vec, remove_dc=True, window="hann", pad_len=int(self.pad_len.get()))\n            f2 = os.path.join(outdir, f"{safe_label}_fft_{ts}.png")\n            fig2, ax2 = plt.subplots(figsize=(9,3.2)); ax2.plot(freqs, power, marker="o")\n            ax2.set_title(f"{label} FFT (DC={mets['dc_frac']:.3f}, H={mets['entropy_bits']:.3f} bits)")\n            ax2.set_xlabel("freq index"); ax2.set_ylabel("power"); ax2.grid(True); fig2.tight_layout(); fig2.savefig(f2); plt.close(fig2)\n            self.export_text.insert("end", f"Saved:\n  {f1}\n  {f2}\n")\n            self._set_status("Paper plots saved.")\n        except Exception as e:\n            messagebox.showerror("Export Error", str(e))\n\nif __name__ == "__main__":\n    app = QTEGUI()\n    app.mainloop()\n\n\n\n# _QTE_REF_EXTRA\n# • [rail]: split positive/negative magnitudes into an extra sign rail.\n# • EGF mode: weights 1/k! using lgamma (stable).\n# • QFT[f(x); N=..; a=..; b=..; ifft]: sample f on [a,b), optional IFFT of samples, then normalize.\n# • Polylog Li(s,z): Euler transform auto-accelerates when z in (-1,0) real.\n\n\ndef _fft_from_gui(amplitudes, **kw):\n    """GUI-safe wrapper around harmonic_analysis.compute_fft_spectrum_from_amplitudes.\n    Always returns a dict with: freq, X, P, dc, entropy_bits, entropy, flatness."""\n    import numpy as _np\n    if harmonic_analysis is None:\n        raise RuntimeError("harmonic_analysis not available")\n    out = harmonic_analysis.compute_fft_spectrum_from_amplitudes(amplitudes, **kw)\n\n    if isinstance(out, dict):  # new API\n        return {\n            "freq": out.get("freq"),\n            "X": out.get("X"),\n            "P": out.get("P"),\n            "dc": out.get("dc"),\n            "entropy_bits": out.get("entropy_bits"),\n            "entropy": out.get("entropy"),\n            "flatness": out.get("flatness"),\n        }\n\n    if isinstance(out, tuple):  # old API: (P,freqs,meta) or (P,freqs)\n        if len(out) == 3:\n            P, freqs, meta = out\n            S = float(_np.sum(P)) or 1.0\n            dc = meta.get("dc_frac", meta.get("dc", float(P[0]/S)))\n            return {\n                "freq": freqs, "X": None, "P": P,\n                "dc": dc,\n                "entropy_bits": meta.get("entropy_bits"),\n                "entropy": meta.get("entropy"),\n                "flatness": meta.get("flatness"),\n            }\n        if len(out) == 2:\n            P, freqs = out\n            S = float(_np.sum(P)) or 1.0\n            return {\n                "freq": freqs, "X": None, "P": P,\n                "dc": float(P[0]/S),\n                "entropy_bits": None, "entropy": None, "flatness": None,\n            }\n\n    raise TypeError("Unexpected FFT output from harmonic_analysis")\n

# --- [QTE patch] runtime wire tabs into QTEGUI after __init__ ---
try:
    pass  # [neutralized import-time wiring]
    def _QTEGUI_init_and_wire(self, *a, **kw):
        _QTEGUI_orig_init(self, *a, **kw)
        try:
            nb = getattr(self, 'nb', None)
            if nb is None:
                return
            if not hasattr(nb, 'qte_tabs'):
                nb.qte_tabs = {}
            if 'EntropyTab' in globals() and EntropyTab is not None and 'Entropy' not in nb.qte_tabs:
                t = EntropyTab(nb); nb.add(t, text='Entropy'); nb.qte_tabs['Entropy'] = t
            if 'SpectrumTab' in globals() and SpectrumTab is not None and 'Spectrum' not in nb.qte_tabs:
                t = SpectrumTab(nb); nb.add(t, text='Spectrum'); nb.qte_tabs['Spectrum'] = t
            if 'PayloadTab' in globals() and PayloadTab is not None and 'Payload' not in nb.qte_tabs:
                t = PayloadTab(nb); nb.add(t, text='Payload'); nb.qte_tabs['Payload'] = t
        except Exception as _e:
            print('[WARN] Could not add transitional tabs:', _e)
    pass  # [neutralized import-time wiring]
except Exception as _e:
    pass  # [neutralized import-time wiring]
